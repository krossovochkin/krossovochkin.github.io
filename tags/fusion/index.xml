<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>fusion on Krossovochkin</title>
    <link>https://krossovochkin.github.io/tags/fusion/</link>
    <description>Recent content in fusion on Krossovochkin</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© 2020 Vasya Drobushkov</copyright>
    <lastBuildDate>Sat, 02 Nov 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://krossovochkin.github.io/tags/fusion/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Operator fusion in RxJava 2</title>
      <link>https://krossovochkin.github.io/posts/operator_fusion_in_rxjava_2_dcd6612cffae/</link>
      <pubDate>Sat, 02 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://krossovochkin.github.io/posts/operator_fusion_in_rxjava_2_dcd6612cffae/</guid>
      <description>Source: https://github.com/ReactiveX
  
 Introduction RxJava is a very powerful library, though it has some issues as well. Specifically performance and memory issues, which come from problems library tries to solve and how the solution is designed from technical perspective. In order to minimize overhead in RxJava there are a number of optimizations, which are called “operator fusion”. And we’ll talk about them in this article. But first let’s recap how RxJava reactive types work and what issues they have.</description>
    </item>
    
  </channel>
</rss>