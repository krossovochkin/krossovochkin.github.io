<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kotlin on Vasya Drobushkov</title>
    <link>https://krossovochkin.com/tags/kotlin/</link>
    <description>Recent content in Kotlin on Vasya Drobushkov</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 17 Feb 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://krossovochkin.com/tags/kotlin/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java after Kotlin</title>
      <link>https://krossovochkin.com/posts/2025_02_17_java_after_kotlin/</link>
      <pubDate>Mon, 17 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://krossovochkin.com/posts/2025_02_17_java_after_kotlin/</guid>
      <description>&lt;p&gt;I am usually pretty slow with new technologies and software updates. That happened with Kotlin a while ago. While version 1.0 was released in early 2016, and many companies were early adopters since the alpha versions, I really started using it only around the end of 2017.&lt;/p&gt;&#xA;&lt;p&gt;I should say that I do find it a very concise and easy-to-write-and-read language. Its focus on developer experience makes it very pleasant to use (except coroutines, lol).&lt;/p&gt;</description>
    </item>
    <item>
      <title>JUnit Coroutines Runner</title>
      <link>https://krossovochkin.com/posts/2021_07_10_junit_coroutines_runner/</link>
      <pubDate>Sat, 10 Jul 2021 00:00:00 +0000</pubDate>
      <guid>https://krossovochkin.com/posts/2021_07_10_junit_coroutines_runner/</guid>
      <description>&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;&#xA;&lt;p&gt;Recently while writing tests for kotlin code with coroutines I found one annoying thing: almost all the tests start with &lt;code&gt;runBlockingTest&lt;/code&gt;. Typing the same stuff repeatedly is something we can&amp;rsquo;t accept! So, I decided to think about how to improve this.&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Disclaimer. Yes, this is an example of how to spend few hours to optimize some task that requires you 2 seconds to complete each time. Even on a scale of hundreds of usages such optimization most likely won&amp;rsquo;t pay your time back. But it is always fun to do some weird things even if you understand that they are stupid.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kotlin flow: Nesting vs Chaining</title>
      <link>https://krossovochkin.com/posts/2021_07_08_kotlin_flow_nesting_vs_chaining/</link>
      <pubDate>Thu, 08 Jul 2021 00:00:00 +0000</pubDate>
      <guid>https://krossovochkin.com/posts/2021_07_08_kotlin_flow_nesting_vs_chaining/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://androidweekly.net/issues/issue-474&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/androidweekly-474-blue#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://mailchi.mp/kotlinweekly/kotlin-weekly-258&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/kotlinweekly-258-purple#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;&#xA;&lt;p&gt;When it comes to reactive streams it is likely everyone heard about huge &amp;lsquo;Rx-chains&amp;rsquo;. But reactive streams are not only about chaining but also about nesting. Let&amp;rsquo;s find out what are they, what are the differences, and why it matters.&lt;br&gt;&#xA;We&amp;rsquo;ll use Kotlin Flow throughout the article, but everything can be applied to RxJava as well.&lt;/p&gt;&#xA;&lt;p&gt;First of all, we need to come up with definitions. For that, we&amp;rsquo;ll take a look at some simple streams.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Custom Reactive JSON parsing</title>
      <link>https://krossovochkin.com/posts/2021_06_08_custom_reactive_json_parsing/</link>
      <pubDate>Tue, 08 Jun 2021 00:00:00 +0000</pubDate>
      <guid>https://krossovochkin.com/posts/2021_06_08_custom_reactive_json_parsing/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://mailchi.mp/kotlinweekly/kotlin-weekly-254&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/kotlinweekly-254-purple#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;&#xA;&lt;p&gt;Parsing JSON strings is a must-have on most Android projects that have server-client communication (of course there are some other formats like XML or &lt;a href=&#34;https://developers.google.com/protocol-buffers&#34;&gt;Protobuf&lt;/a&gt;, but I guess JSON is the most common one at least at the moment). Setting up this communication is relatively straightforward: choose a library, add it to a project, describe models, create mappers, and so on. There are a bunch of various libraries to parse JSON: good old &lt;a href=&#34;https://github.com/google/gson&#34;&gt;Gson&lt;/a&gt;, &lt;a href=&#34;https://github.com/FasterXML/jackson&#34;&gt;Jackson&lt;/a&gt;, or more modern &lt;a href=&#34;https://github.com/square/moshi&#34;&gt;Moshi&lt;/a&gt;, &lt;a href=&#34;https://github.com/Kotlin/kotlinx.serialization&#34;&gt;kotlinx-serialization&lt;/a&gt; and there are more. Set up of these libraries is different, there are differences in the internal implementation, but the general idea is the same for most of them: you can convert JSON-string into a set of objects and vice versa.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Bad Kotlin Extensions</title>
      <link>https://krossovochkin.com/posts/2021_01_25_bad_kotlin_extensions/</link>
      <pubDate>Mon, 25 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://krossovochkin.com/posts/2021_01_25_bad_kotlin_extensions/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://images.unsplash.com/photo-1598518619776-eae3f8a34eac?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&amp;amp;ixlib=rb-1.2.1&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1351&amp;amp;q=80&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://androidweekly.net/issues/issue-451&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/androidweekly-451-blue#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://mailchi.mp/kotlinweekly/kotlin-weekly-236&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/kotlinweekly-236-purple#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.oncreatedigest.com/issues/oncreate-digest-issue-41-309824&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/oncreate-41-ff69b4#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;&#xA;&lt;p&gt;Kotlin extensions are a cool feature. Though trying to write &amp;lsquo;idiomatic&amp;rsquo; Kotlin code some developers tend to overuse that feature making code worse than it could be without extensions. In this article, we&amp;rsquo;ll go through some examples of how not to write Kotlin extensions.&lt;/p&gt;&#xA;&lt;p&gt;First of all, we need to try to define what a good extension is.&lt;br&gt;&#xA;It is simple though vague: good extension solves some problems. When we talk about code the main feature extensions have is to improve readability. Extension methods are static methods with the first parameter being a receiver of the extension. For example, these are equivalents:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Boolean not</title>
      <link>https://krossovochkin.com/posts/2020_10_31_boolean_not/</link>
      <pubDate>Sat, 31 Oct 2020 00:00:00 +0000</pubDate>
      <guid>https://krossovochkin.com/posts/2020_10_31_boolean_not/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://mailchi.mp/kotlinweekly/gjz7gia1eq&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/kotlinweekly-222-purple#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;&#xA;&lt;p&gt;Boolean is one of the essential types in programming and probably one of the simplest because it has only two values: true and false. Boolean are usually used as flags for control flow, specifically, conditions.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;isEmpty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;String is empty&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It is not much interesting in Boolean, but in Kotlin there is one thing which might be confusing if used - it is method &lt;code&gt;not()&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;h3 id=&#34;negate-boolean&#34;&gt;Negate Boolean&lt;/h3&gt;&#xA;&lt;p&gt;If we look at declaration of Boolean class in Kotlin we&amp;rsquo;ll see five methods, four of which are pretty obvious: &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;xor&lt;/code&gt; and &lt;code&gt;compareTo&lt;/code&gt;. And the fifth is &lt;code&gt;not&lt;/code&gt;:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kotlin Functional Interfaces: Function reference and SAM conversion</title>
      <link>https://krossovochkin.com/posts/2020_10_17_kotlin_functional_interfaces_function_references_and_sam_conversion/</link>
      <pubDate>Sat, 17 Oct 2020 00:00:00 +0000</pubDate>
      <guid>https://krossovochkin.com/posts/2020_10_17_kotlin_functional_interfaces_function_references_and_sam_conversion/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://mailchi.mp/kotlinweekly/kotlin-weekly-220&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/kotlinweekly-220-purple#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;&#xA;&lt;p&gt;About two years ago I &lt;a href=&#34;https://medium.com/@krossovochkin/kotlin-java-interop-function-references-and-sam-conversions-3d0cd36f7967&#34;&gt;made a post&lt;/a&gt; about a tricky case in Kotlin-Java interop related to the usage of function references and SAM conversion.&#xA;One of the points there was that in Kotlin, if interface is declared instead of a function, one has to explicitly create an object, therefore no caveats as with interop:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;py&#34;&gt;callback&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;object&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;: &lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;ThirdParty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Callback&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;override&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;fun&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;onValueChanged&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@App&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;onValueChanged&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;With Kotlin 1.4 there is now a &amp;ldquo;Functional interface&amp;rdquo; which supports SAM conversion. And &lt;a href=&#34;https://medium.com/@mwolfe38/does-the-new-kotlin-1-4-sam-interfaces-using-fun-interface-declaration-have-similar-issues-1b08fa65a096&#34;&gt;I&amp;rsquo;ve been asked&lt;/a&gt; on how it works in a similar situation.&lt;br&gt;&#xA;Let&amp;rsquo;s find out.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kotlin Nitpicker&#39;s guide</title>
      <link>https://krossovochkin.com/posts/2020_10_14_kotlin_nitpickers_guide/</link>
      <pubDate>Wed, 14 Oct 2020 00:00:00 +0000</pubDate>
      <guid>https://krossovochkin.com/posts/2020_10_14_kotlin_nitpickers_guide/</guid>
      <description>&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;&#xA;&lt;p&gt;Code review is an essential tool for a development team, which helps ensure high-quality standards of code. While reviewing others&amp;rsquo; code one might find bugs, design issues, and so on. One another part of reviewing is getting used to the codebase and following team&amp;rsquo;s code style for better maintenance.&#xA;Though it is pretty cool in theory, in practice team might face few issues, one of which is nitpicking. When review is bloated with dozens of similar comments related to e.g. how beautifully code looks like.&#xA;Common code style is important, but having a lot of similar comments in each review doesn&amp;rsquo;t help. Instead of trying to understand what code is doing, nitpicker writes a lot of similar comments on the style. Back and forth discussions or fixes of such slow down development process and overall make team&amp;rsquo;s morale worse.&lt;/p&gt;</description>
    </item>
    <item>
      <title>The Real Kotlin Flow benefits over RxJava</title>
      <link>https://krossovochkin.com/posts/2020_05_17_the_real_kotlin_flow_benefits_over_rxjava/</link>
      <pubDate>Sun, 17 May 2020 00:00:00 +0000</pubDate>
      <guid>https://krossovochkin.com/posts/2020_05_17_the_real_kotlin_flow_benefits_over_rxjava/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://images.unsplash.com/photo-1553877522-43269d4ea984?ixlib=rb-1.2.1&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1357&amp;amp;q=80&#34; alt=&#34;Source&#34;&gt;&lt;em&gt;&lt;a href=&#34;https://unsplash.com/photos/Lks7vei-eAg&#34;&gt;Source&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://proandroiddev.com/the-real-kotlin-flow-benefits-over-rxjava-c19b99ba6eb9&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/original-proandroiddev-green#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://proandroiddev.com/proandroiddev-digest-22-a7bf64f9f068&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/proandroiddevdigest-22-green#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;Recently the article about Kotlin Flow benefits over RxJava was published by &lt;a href=&#34;undefined&#34;&gt;Antoni Castejón García&lt;/a&gt;:&#xA;&lt;a href=&#34;https://proandroiddev.com/kotlin-flow-benefits-over-rxjava-b220658f1a92&#34;&gt;&lt;strong&gt;Kotlin Flow benefits over RxJava&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;Though Antoni made a good work and many thanks to him for providing his feedback and experience (we need to share our thoughts, this improves community acknowledgment in various areas) — I found few places in the article with which I don’t fully or partially agree. Some points, in my opinion, were missing. So, I decided to make a follow-up feedback post on what I consider the real benefits of Kotlin Flow over RxJava. Feedback is also a good thing as it helps us to drive forward and maybe look at the same things from a different angle.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kotlin useful but unfairly not mentioned features</title>
      <link>https://krossovochkin.com/posts/2020_05_03_kotlin_useful_but_unfairly_not_mentioned_features/</link>
      <pubDate>Sun, 03 May 2020 00:00:00 +0000</pubDate>
      <guid>https://krossovochkin.com/posts/2020_05_03_kotlin_useful_but_unfairly_not_mentioned_features/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://images.unsplash.com/photo-1519963759188-0e9264cd7992?ixlib=rb-1.2.1&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1357&amp;amp;q=80&#34; alt=&#34;Source&#34;&gt;&lt;em&gt;&lt;a href=&#34;https://unsplash.com/photos/5EoKAdyStik&#34;&gt;Source&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://proandroiddev.com/kotlin-useful-but-unfairly-not-mentioned-features-25ec41ea0a87&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/original-proandroiddev-green#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://proandroiddev.com/proandroiddev-digest-21-60de024d6337&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/proandroiddevdigest-21-green#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;Many of us first learned Kotlin after Java. Learning process was fairly simple because Kotlin has many similarities when at the same time improves development experience by fighting common pain points Java developer (especially on Java 6, which is common in Android world) has to encounter every day.&lt;/p&gt;&#xA;&lt;p&gt;There are a bunch of articles about cool Kotlin features like immutability, handling nullability, smart-cast, data classes, and so forth. Yes, these features are great. Having to add a bunch of nullability annotations, final keywords, override equals/hashCode methods, create additional local variables after type checks — all of this adds unnecessary work that needs to be done all the time.&lt;/p&gt;</description>
    </item>
    <item>
      <title>From RxJava to Kotlin Flow: Testing</title>
      <link>https://krossovochkin.com/posts/2020_03_05_from_rxjava_to_kotlin_flow_testing/</link>
      <pubDate>Thu, 05 Mar 2020 00:00:00 +0000</pubDate>
      <guid>https://krossovochkin.com/posts/2020_03_05_from_rxjava_to_kotlin_flow_testing/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://images.unsplash.com/photo-1574170609519-d1d8d4b71f60?ixlib=rb-1.2.1&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1357&amp;amp;q=80&#34; alt=&#34;Source&#34;&gt;&lt;em&gt;&lt;a href=&#34;https://unsplash.com/photos/9kSTF9PvETM&#34;&gt;Source&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;This post is part of series of comparing RxJava to Kotlin Flow. Previous articles were about &lt;a href=&#34;https://proandroiddev.com/from-rxjava-2-to-kotlin-flow-threading-8618867e1955&#34;&gt;Threading&lt;/a&gt;, &lt;a href=&#34;https://proandroiddev.com/from-rxjava-to-kotlin-flow-backpressure-d1fb91e6dea8&#34;&gt;Backpressure&lt;/a&gt;, &lt;a href=&#34;https://proandroiddev.com/from-rxjava-to-kotlin-flow-error-handling-da1f6a4f2708&#34;&gt;Error Handling,&lt;/a&gt; &lt;a href=&#34;https://proandroiddev.com/from-rxjava-to-kotlin-flow-stream-types-7916be6cabc2&#34;&gt;Stream Types&lt;/a&gt;, &lt;a href=&#34;https://proandroiddev.com/from-rxjava-to-kotlin-flow-throttling-ed1778847619&#34;&gt;Throttling&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://proandroiddev.com/from-rxjava-to-kotlin-flow-testing-42f1641d8433&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/original-proandroiddev-green#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;Testing is a crucial part of whole development. Testing allows you to write programs in a reliable fashion, prevent regressions and have many other goodies. I won’t go through the list of advantages of writing tests in this article though.&#xA;In testing it is important to have tools which allow you to write reliable tests and also tools which allow you to test your business logic.&#xA;Business logic might be inside some function which calculates data and returns result, but also it might be some loading of data from network or doing some work in reaction to UI events. In places where we might have RxJava integrated. So it is very important to be able to test our rx-chains.&#xA;In this article we’ll go through the most important concepts in RxJava testing and compare it with what we have in Kotlin Flow.&lt;/p&gt;</description>
    </item>
    <item>
      <title>From RxJava to Kotlin Flow: Throttling</title>
      <link>https://krossovochkin.com/posts/2020_03_02_from_rxjava_to_kotlin_flow_throttling/</link>
      <pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate>
      <guid>https://krossovochkin.com/posts/2020_03_02_from_rxjava_to_kotlin_flow_throttling/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://images.unsplash.com/photo-1538474705339-e87de81450e8?ixlib=rb-1.2.1&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1357&amp;amp;q=80&#34; alt=&#34;Source&#34;&gt;&lt;em&gt;&lt;a href=&#34;https://unsplash.com/photos/scUBcasSvbE&#34;&gt;Source&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;This post is part of series of comparing RxJava to Kotlin Flow. Previous articles were about &lt;a href=&#34;https://proandroiddev.com/from-rxjava-2-to-kotlin-flow-threading-8618867e1955&#34;&gt;Threading&lt;/a&gt;, &lt;a href=&#34;https://proandroiddev.com/from-rxjava-to-kotlin-flow-backpressure-d1fb91e6dea8&#34;&gt;Backpressure&lt;/a&gt;, &lt;a href=&#34;https://proandroiddev.com/from-rxjava-to-kotlin-flow-error-handling-da1f6a4f2708&#34;&gt;Error Handling,&lt;/a&gt; &lt;a href=&#34;https://proandroiddev.com/from-rxjava-to-kotlin-flow-stream-types-7916be6cabc2&#34;&gt;Stream Types&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://proandroiddev.com/from-rxjava-to-kotlin-flow-throttling-ed1778847619&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/original-proandroiddev-green#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://proandroiddev.com/proandroiddev-digest-17-d52bc575edb6&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/proandroiddevdigest-17-green#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;It is advised to take a look at the overview of Throttling operators in RxJava before reading this article:&#xA;&lt;a href=&#34;https://proandroiddev.com/throttling-in-rxjava-2-d640ea5f7bf1&#34;&gt;&lt;strong&gt;Throttling in RxJava 2&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;Throttling is also one of the essential features of reactive programming. Streams might emit more values than we’re expecting to receive, so ability to limit number of events in a stream is very important.&#xA;Most common place where it applies is handling UI events. Examples of usage might be handling button clicks (to not allow double clicks), usage with search view when we’d like to wait for user to stop typing before querying some data and so on.&#xA;In this article we’ll try to compare throttling operators in RxJava and Kotlin Flow.&lt;/p&gt;</description>
    </item>
    <item>
      <title>From RxJava to Kotlin Flow: Stream Types</title>
      <link>https://krossovochkin.com/posts/2020_02_26_from_rxjava_to_kotlin_flow_stream_types/</link>
      <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
      <guid>https://krossovochkin.com/posts/2020_02_26_from_rxjava_to_kotlin_flow_stream_types/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://images.unsplash.com/photo-1516192891955-70642cf1ac88?ixlib=rb-1.2.1&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1357&amp;amp;q=80&#34; alt=&#34;Source&#34;&gt;&lt;em&gt;&lt;a href=&#34;https://unsplash.com/photos/JcimvPDC3as&#34;&gt;Source&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;This post is part of series of comparing RxJava to Kotlin Flow. Previous articles were about &lt;a href=&#34;https://proandroiddev.com/from-rxjava-2-to-kotlin-flow-threading-8618867e1955&#34;&gt;Threading&lt;/a&gt;, &lt;a href=&#34;https://proandroiddev.com/from-rxjava-to-kotlin-flow-backpressure-d1fb91e6dea8&#34;&gt;Backpressure&lt;/a&gt;, &lt;a href=&#34;https://proandroiddev.com/from-rxjava-to-kotlin-flow-error-handling-da1f6a4f2708&#34;&gt;Error Handling&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://proandroiddev.com/from-rxjava-to-kotlin-flow-stream-types-7916be6cabc2&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/original-proandroiddev-green#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://proandroiddev.com/proandroiddev-digest-16-e17b7e8ae48b&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/proandroiddevdigest-16-green#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;In reactive programming we use streams. Therefore in both RxJava and Kotlin Flow we’ll have to use some streams. Though we’ll encounter some differences if we decide to migrate.&#xA;In this article we’ll try to get into the stream types which have RxJava and Kotlin Flow and some important differences.&lt;/p&gt;</description>
    </item>
    <item>
      <title>From RxJava to Kotlin Flow: Error Handling</title>
      <link>https://krossovochkin.com/posts/2020_02_24_from_rxjava_to_kotlin_flow_error_handling/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      <guid>https://krossovochkin.com/posts/2020_02_24_from_rxjava_to_kotlin_flow_error_handling/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://images.unsplash.com/photo-1580357991342-89ec1672c98a?ixlib=rb-1.2.1&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1357&amp;amp;q=80&#34; alt=&#34;Source&#34;&gt;&lt;em&gt;&lt;a href=&#34;https://unsplash.com/photos/aYNyC6fIH84&#34;&gt;Source&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;This post is part of series of comparing RxJava to Kotlin Flow. Previous articles were about &lt;a href=&#34;https://proandroiddev.com/from-rxjava-2-to-kotlin-flow-threading-8618867e1955&#34;&gt;Threading &lt;/a&gt;and &lt;a href=&#34;https://proandroiddev.com/from-rxjava-to-kotlin-flow-backpressure-d1fb91e6dea8&#34;&gt;Backpressure&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://proandroiddev.com/from-rxjava-to-kotlin-flow-error-handling-da1f6a4f2708&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/original-proandroiddev-green#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;Error handling is fundamental in reactive programming. Reactive streams might fail with exception and propagate it as an event downstream notifying consumers on the error that happened.&#xA;As in previous articles, we’ll try to compare RxJava and Kotlin Flow error handling mechanisms. This might help us to migrate existing code from RxJava to Kotlin Flow and also understand how to properly use Kotlin Flow.&lt;/p&gt;</description>
    </item>
    <item>
      <title>From RxJava to Kotlin Flow: Backpressure</title>
      <link>https://krossovochkin.com/posts/2020_02_06_from_rxjava_to_kotlin_flow_backpressure/</link>
      <pubDate>Thu, 06 Feb 2020 00:00:00 +0000</pubDate>
      <guid>https://krossovochkin.com/posts/2020_02_06_from_rxjava_to_kotlin_flow_backpressure/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://proandroiddev.com/from-rxjava-to-kotlin-flow-backpressure-d1fb91e6dea8&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/original-proandroiddev-green#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://androidweekly.net/issues/issue-400&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/androidweekly-400-blue#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://proandroiddev.com/proandroiddev-digest-15-b467005869ce&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/proandroiddevdigest-15-green#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Disclaimer&#xA;This article unfortunately is not that dive deep (because of complexity of internals of coroutines), but instead trying to compare RxJava and Kotlin Flow mostly as black box with trying to find out differences in behavior and how to migrate from RxJava with its backpressure solution to Kotlin Flow.&#xA;Hopefully this article will give you direction on where to look at if you decide to migrate to Kotlin Flow.&lt;/p&gt;</description>
    </item>
    <item>
      <title>From RxJava 2 to Kotlin Flow: Threading</title>
      <link>https://krossovochkin.com/posts/2020_01_25_from_rxjava_2_to_kotlin_flow_threading/</link>
      <pubDate>Sat, 25 Jan 2020 00:00:00 +0000</pubDate>
      <guid>https://krossovochkin.com/posts/2020_01_25_from_rxjava_2_to_kotlin_flow_threading/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://images.unsplash.com/photo-1552034412-443022194b52?ixlib=rb-1.2.1&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1357&amp;amp;q=80&#34; alt=&#34;Source&#34;&gt;&lt;em&gt;&lt;a href=&#34;https://unsplash.com/photos/vyyVbUOYNPc&#34;&gt;Source&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://proandroiddev.com/from-rxjava-2-to-kotlin-flow-threading-8618867e1955&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/original-proandroiddev-green#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://androidweekly.net/issues/issue-398&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/androidweekly-398-blue#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://proandroiddev.com/proandroiddev-digest-14-b7247f25292f&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/proandroiddevdigest-14-green#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;For a long time RxJava was undisputed leader for reactive solutions on Android, though with Kotlin expansion and introducing cold streams (Flow) seems situation might be rapidly changing in the coming years.&#xA;Though reactive programming is not related to threading in the first place, concurrency and parallelism are very important anyway.&#xA;In this article we’ll try to make short recap on threading in RxJava 2 (with some basic caveats on its usage) and then take a look at how threading works in Kotlin Flow, so if anyone would like to migrate their code without affecting functionality it would be nice and smooth.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kotlin-Java interop: function references and SAM conversions</title>
      <link>https://krossovochkin.com/posts/2018_09_13_kotlin_java_interop_function_references_and_sam_conversions/</link>
      <pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate>
      <guid>https://krossovochkin.com/posts/2018_09_13_kotlin_java_interop_function_references_and_sam_conversions/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://medium.com/@krossovochkin/kotlin-java-interop-function-references-and-sam-conversions-3d0cd36f7967&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/original-medium-green#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;Though all the things below are pretty obvious if being careful while dealing with Kotlin-Java interop, I decided still to write short note about one particular issue with function references (from Kotlin side) and SAM conversions (from Java side).&lt;/p&gt;&#xA;&lt;h3 id=&#34;function-reference&#34;&gt;Function reference&lt;/h3&gt;&#xA;&lt;p&gt;Function reference is a good way to pass function as a parameter without explicitly using lambdas.&lt;/p&gt;&#xA;&lt;p&gt;For example, if we have function:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;fun&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;callback&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Output&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;..&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;then we can pass our function as a lambda with function call or as a function reference:&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
