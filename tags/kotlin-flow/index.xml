<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kotlin flow on Vasya Drobushkov</title>
    <link>https://krossovochkin.com/tags/kotlin-flow/</link>
    <description>Recent content in kotlin flow on Vasya Drobushkov</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 08 Jul 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://krossovochkin.com/tags/kotlin-flow/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Kotlin flow: Nesting vs Chaining</title>
      <link>https://krossovochkin.com/posts/2021_07_08_kotlin_flow_nesting_vs_chaining/</link>
      <pubDate>Thu, 08 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://krossovochkin.com/posts/2021_07_08_kotlin_flow_nesting_vs_chaining/</guid>
      <description>Introduction When it comes to reactive streams it is likely everyone heard about huge &amp;lsquo;Rx-chains&amp;rsquo;. But reactive streams are not only about chaining but also about nesting. Let&amp;rsquo;s find out what are they, what are the differences, and why it matters.
We&amp;rsquo;ll use Kotlin Flow throughout the article, but everything can be applied to RxJava as well.
First of all, we need to come up with definitions. For that, we&amp;rsquo;ll take a look at some simple streams.</description>
    </item>
    
    <item>
      <title>The Real Kotlin Flow benefits over RxJava</title>
      <link>https://krossovochkin.com/posts/2020_05_17_the_real_kotlin_flow_benefits_over_rxjava/</link>
      <pubDate>Sun, 17 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://krossovochkin.com/posts/2020_05_17_the_real_kotlin_flow_benefits_over_rxjava/</guid>
      <description>Source
 
Introduction Recently the article about Kotlin Flow benefits over RxJava was published by Antoni Castejón García: Kotlin Flow benefits over RxJava
Though Antoni made a good work and many thanks to him for providing his feedback and experience (we need to share our thoughts, this improves community acknowledgment in various areas) — I found few places in the article with which I don’t fully or partially agree. Some points, in my opinion, were missing.</description>
    </item>
    
    <item>
      <title>From RxJava to Kotlin Flow: Testing</title>
      <link>https://krossovochkin.com/posts/2020_03_05_from_rxjava_to_kotlin_flow_testing/</link>
      <pubDate>Thu, 05 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://krossovochkin.com/posts/2020_03_05_from_rxjava_to_kotlin_flow_testing/</guid>
      <description>Source
 This post is part of series of comparing RxJava to Kotlin Flow. Previous articles were about Threading, Backpressure, Error Handling, Stream Types, Throttling
 
Introduction Testing is a crucial part of whole development. Testing allows you to write programs in a reliable fashion, prevent regressions and have many other goodies. I won’t go through the list of advantages of writing tests in this article though. In testing it is important to have tools which allow you to write reliable tests and also tools which allow you to test your business logic.</description>
    </item>
    
    <item>
      <title>From RxJava to Kotlin Flow: Throttling</title>
      <link>https://krossovochkin.com/posts/2020_03_02_from_rxjava_to_kotlin_flow_throttling/</link>
      <pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://krossovochkin.com/posts/2020_03_02_from_rxjava_to_kotlin_flow_throttling/</guid>
      <description>Source
 This post is part of series of comparing RxJava to Kotlin Flow. Previous articles were about Threading, Backpressure, Error Handling, Stream Types
  
It is advised to take a look at the overview of Throttling operators in RxJava before reading this article: Throttling in RxJava 2
Introduction Throttling is also one of the essential features of reactive programming. Streams might emit more values than we’re expecting to receive, so ability to limit number of events in a stream is very important.</description>
    </item>
    
    <item>
      <title>From RxJava to Kotlin Flow: Stream Types</title>
      <link>https://krossovochkin.com/posts/2020_02_26_from_rxjava_to_kotlin_flow_stream_types/</link>
      <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://krossovochkin.com/posts/2020_02_26_from_rxjava_to_kotlin_flow_stream_types/</guid>
      <description>Source
 This post is part of series of comparing RxJava to Kotlin Flow. Previous articles were about Threading, Backpressure, Error Handling
  
Introduction In reactive programming we use streams. Therefore in both RxJava and Kotlin Flow we’ll have to use some streams. Though we’ll encounter some differences if we decide to migrate. In this article we’ll try to get into the stream types which have RxJava and Kotlin Flow and some important differences.</description>
    </item>
    
    <item>
      <title>From RxJava to Kotlin Flow: Error Handling</title>
      <link>https://krossovochkin.com/posts/2020_02_24_from_rxjava_to_kotlin_flow_error_handling/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://krossovochkin.com/posts/2020_02_24_from_rxjava_to_kotlin_flow_error_handling/</guid>
      <description>Source
 This post is part of series of comparing RxJava to Kotlin Flow. Previous articles were about Threading and Backpressure.
 
Introduction Error handling is fundamental in reactive programming. Reactive streams might fail with exception and propagate it as an event downstream notifying consumers on the error that happened. As in previous articles, we’ll try to compare RxJava and Kotlin Flow error handling mechanisms. This might help us to migrate existing code from RxJava to Kotlin Flow and also understand how to properly use Kotlin Flow.</description>
    </item>
    
    <item>
      <title>From RxJava to Kotlin Flow: Backpressure</title>
      <link>https://krossovochkin.com/posts/2020_02_06_from_rxjava_to_kotlin_flow_backpressure/</link>
      <pubDate>Thu, 06 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://krossovochkin.com/posts/2020_02_06_from_rxjava_to_kotlin_flow_backpressure/</guid>
      <description>Disclaimer This article unfortunately is not that dive deep (because of complexity of internals of coroutines), but instead trying to compare RxJava and Kotlin Flow mostly as black box with trying to find out differences in behavior and how to migrate from RxJava with its backpressure solution to Kotlin Flow. Hopefully this article will give you direction on where to look at if you decide to migrate to Kotlin Flow.</description>
    </item>
    
    <item>
      <title>From RxJava 2 to Kotlin Flow: Threading</title>
      <link>https://krossovochkin.com/posts/2020_01_25_from_rxjava_2_to_kotlin_flow_threading/</link>
      <pubDate>Sat, 25 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://krossovochkin.com/posts/2020_01_25_from_rxjava_2_to_kotlin_flow_threading/</guid>
      <description>Source
  
Introduction For a long time RxJava was undisputed leader for reactive solutions on Android, though with Kotlin expansion and introducing cold streams (Flow) seems situation might be rapidly changing in the coming years. Though reactive programming is not related to threading in the first place, concurrency and parallelism are very important anyway. In this article we’ll try to make short recap on threading in RxJava 2 (with some basic caveats on its usage) and then take a look at how threading works in Kotlin Flow, so if anyone would like to migrate their code without affecting functionality it would be nice and smooth.</description>
    </item>
    
  </channel>
</rss>
