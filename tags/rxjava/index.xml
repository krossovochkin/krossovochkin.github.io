<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rxjava on Vasya Drobushkov</title>
    <link>https://krossovochkin.com/tags/rxjava/</link>
    <description>Recent content in Rxjava on Vasya Drobushkov</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 08 Jan 2023 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://krossovochkin.com/tags/rxjava/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Reactive streams testing</title>
      <link>https://krossovochkin.com/posts/2023_01_08_reactive_streams_testing/</link>
      <pubDate>Sun, 08 Jan 2023 00:00:00 +0000</pubDate>
      <guid>https://krossovochkin.com/posts/2023_01_08_reactive_streams_testing/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;We should test the code to guarantee that it does exactly what it is expected to do. Tests not only verify correctness of the program but also set expectations. This becomes especially useful for public API, where tests can be treated as part of documentation that describes not only results but also behavior. Such things help do less painful migrations and refactoring as it becomes clear what behaviors are changing and what we should do about that.&lt;/p&gt;</description>
    </item>
    <item>
      <title>The Real Kotlin Flow benefits over RxJava</title>
      <link>https://krossovochkin.com/posts/2020_05_17_the_real_kotlin_flow_benefits_over_rxjava/</link>
      <pubDate>Sun, 17 May 2020 00:00:00 +0000</pubDate>
      <guid>https://krossovochkin.com/posts/2020_05_17_the_real_kotlin_flow_benefits_over_rxjava/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://images.unsplash.com/photo-1553877522-43269d4ea984?ixlib=rb-1.2.1&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1357&amp;amp;q=80&#34; alt=&#34;Source&#34;&gt;&lt;em&gt;&lt;a href=&#34;https://unsplash.com/photos/Lks7vei-eAg&#34;&gt;Source&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://proandroiddev.com/the-real-kotlin-flow-benefits-over-rxjava-c19b99ba6eb9&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/original-proandroiddev-green#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://proandroiddev.com/proandroiddev-digest-22-a7bf64f9f068&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/proandroiddevdigest-22-green#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;Recently the article about Kotlin Flow benefits over RxJava was published by &lt;a href=&#34;undefined&#34;&gt;Antoni Castejón García&lt;/a&gt;:&#xA;&lt;a href=&#34;https://proandroiddev.com/kotlin-flow-benefits-over-rxjava-b220658f1a92&#34;&gt;&lt;strong&gt;Kotlin Flow benefits over RxJava&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;Though Antoni made a good work and many thanks to him for providing his feedback and experience (we need to share our thoughts, this improves community acknowledgment in various areas) — I found few places in the article with which I don’t fully or partially agree. Some points, in my opinion, were missing. So, I decided to make a follow-up feedback post on what I consider the real benefits of Kotlin Flow over RxJava. Feedback is also a good thing as it helps us to drive forward and maybe look at the same things from a different angle.&lt;/p&gt;</description>
    </item>
    <item>
      <title>From RxJava to Kotlin Flow: Testing</title>
      <link>https://krossovochkin.com/posts/2020_03_05_from_rxjava_to_kotlin_flow_testing/</link>
      <pubDate>Thu, 05 Mar 2020 00:00:00 +0000</pubDate>
      <guid>https://krossovochkin.com/posts/2020_03_05_from_rxjava_to_kotlin_flow_testing/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://images.unsplash.com/photo-1574170609519-d1d8d4b71f60?ixlib=rb-1.2.1&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1357&amp;amp;q=80&#34; alt=&#34;Source&#34;&gt;&lt;em&gt;&lt;a href=&#34;https://unsplash.com/photos/9kSTF9PvETM&#34;&gt;Source&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;This post is part of series of comparing RxJava to Kotlin Flow. Previous articles were about &lt;a href=&#34;https://proandroiddev.com/from-rxjava-2-to-kotlin-flow-threading-8618867e1955&#34;&gt;Threading&lt;/a&gt;, &lt;a href=&#34;https://proandroiddev.com/from-rxjava-to-kotlin-flow-backpressure-d1fb91e6dea8&#34;&gt;Backpressure&lt;/a&gt;, &lt;a href=&#34;https://proandroiddev.com/from-rxjava-to-kotlin-flow-error-handling-da1f6a4f2708&#34;&gt;Error Handling,&lt;/a&gt; &lt;a href=&#34;https://proandroiddev.com/from-rxjava-to-kotlin-flow-stream-types-7916be6cabc2&#34;&gt;Stream Types&lt;/a&gt;, &lt;a href=&#34;https://proandroiddev.com/from-rxjava-to-kotlin-flow-throttling-ed1778847619&#34;&gt;Throttling&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://proandroiddev.com/from-rxjava-to-kotlin-flow-testing-42f1641d8433&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/original-proandroiddev-green#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;Testing is a crucial part of whole development. Testing allows you to write programs in a reliable fashion, prevent regressions and have many other goodies. I won’t go through the list of advantages of writing tests in this article though.&#xA;In testing it is important to have tools which allow you to write reliable tests and also tools which allow you to test your business logic.&#xA;Business logic might be inside some function which calculates data and returns result, but also it might be some loading of data from network or doing some work in reaction to UI events. In places where we might have RxJava integrated. So it is very important to be able to test our rx-chains.&#xA;In this article we’ll go through the most important concepts in RxJava testing and compare it with what we have in Kotlin Flow.&lt;/p&gt;</description>
    </item>
    <item>
      <title>From RxJava to Kotlin Flow: Throttling</title>
      <link>https://krossovochkin.com/posts/2020_03_02_from_rxjava_to_kotlin_flow_throttling/</link>
      <pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate>
      <guid>https://krossovochkin.com/posts/2020_03_02_from_rxjava_to_kotlin_flow_throttling/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://images.unsplash.com/photo-1538474705339-e87de81450e8?ixlib=rb-1.2.1&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1357&amp;amp;q=80&#34; alt=&#34;Source&#34;&gt;&lt;em&gt;&lt;a href=&#34;https://unsplash.com/photos/scUBcasSvbE&#34;&gt;Source&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;This post is part of series of comparing RxJava to Kotlin Flow. Previous articles were about &lt;a href=&#34;https://proandroiddev.com/from-rxjava-2-to-kotlin-flow-threading-8618867e1955&#34;&gt;Threading&lt;/a&gt;, &lt;a href=&#34;https://proandroiddev.com/from-rxjava-to-kotlin-flow-backpressure-d1fb91e6dea8&#34;&gt;Backpressure&lt;/a&gt;, &lt;a href=&#34;https://proandroiddev.com/from-rxjava-to-kotlin-flow-error-handling-da1f6a4f2708&#34;&gt;Error Handling,&lt;/a&gt; &lt;a href=&#34;https://proandroiddev.com/from-rxjava-to-kotlin-flow-stream-types-7916be6cabc2&#34;&gt;Stream Types&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://proandroiddev.com/from-rxjava-to-kotlin-flow-throttling-ed1778847619&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/original-proandroiddev-green#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://proandroiddev.com/proandroiddev-digest-17-d52bc575edb6&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/proandroiddevdigest-17-green#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;It is advised to take a look at the overview of Throttling operators in RxJava before reading this article:&#xA;&lt;a href=&#34;https://proandroiddev.com/throttling-in-rxjava-2-d640ea5f7bf1&#34;&gt;&lt;strong&gt;Throttling in RxJava 2&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;Throttling is also one of the essential features of reactive programming. Streams might emit more values than we’re expecting to receive, so ability to limit number of events in a stream is very important.&#xA;Most common place where it applies is handling UI events. Examples of usage might be handling button clicks (to not allow double clicks), usage with search view when we’d like to wait for user to stop typing before querying some data and so on.&#xA;In this article we’ll try to compare throttling operators in RxJava and Kotlin Flow.&lt;/p&gt;</description>
    </item>
    <item>
      <title>From RxJava to Kotlin Flow: Stream Types</title>
      <link>https://krossovochkin.com/posts/2020_02_26_from_rxjava_to_kotlin_flow_stream_types/</link>
      <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
      <guid>https://krossovochkin.com/posts/2020_02_26_from_rxjava_to_kotlin_flow_stream_types/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://images.unsplash.com/photo-1516192891955-70642cf1ac88?ixlib=rb-1.2.1&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1357&amp;amp;q=80&#34; alt=&#34;Source&#34;&gt;&lt;em&gt;&lt;a href=&#34;https://unsplash.com/photos/JcimvPDC3as&#34;&gt;Source&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;This post is part of series of comparing RxJava to Kotlin Flow. Previous articles were about &lt;a href=&#34;https://proandroiddev.com/from-rxjava-2-to-kotlin-flow-threading-8618867e1955&#34;&gt;Threading&lt;/a&gt;, &lt;a href=&#34;https://proandroiddev.com/from-rxjava-to-kotlin-flow-backpressure-d1fb91e6dea8&#34;&gt;Backpressure&lt;/a&gt;, &lt;a href=&#34;https://proandroiddev.com/from-rxjava-to-kotlin-flow-error-handling-da1f6a4f2708&#34;&gt;Error Handling&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://proandroiddev.com/from-rxjava-to-kotlin-flow-stream-types-7916be6cabc2&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/original-proandroiddev-green#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://proandroiddev.com/proandroiddev-digest-16-e17b7e8ae48b&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/proandroiddevdigest-16-green#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;In reactive programming we use streams. Therefore in both RxJava and Kotlin Flow we’ll have to use some streams. Though we’ll encounter some differences if we decide to migrate.&#xA;In this article we’ll try to get into the stream types which have RxJava and Kotlin Flow and some important differences.&lt;/p&gt;</description>
    </item>
    <item>
      <title>From RxJava to Kotlin Flow: Error Handling</title>
      <link>https://krossovochkin.com/posts/2020_02_24_from_rxjava_to_kotlin_flow_error_handling/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      <guid>https://krossovochkin.com/posts/2020_02_24_from_rxjava_to_kotlin_flow_error_handling/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://images.unsplash.com/photo-1580357991342-89ec1672c98a?ixlib=rb-1.2.1&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1357&amp;amp;q=80&#34; alt=&#34;Source&#34;&gt;&lt;em&gt;&lt;a href=&#34;https://unsplash.com/photos/aYNyC6fIH84&#34;&gt;Source&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;This post is part of series of comparing RxJava to Kotlin Flow. Previous articles were about &lt;a href=&#34;https://proandroiddev.com/from-rxjava-2-to-kotlin-flow-threading-8618867e1955&#34;&gt;Threading &lt;/a&gt;and &lt;a href=&#34;https://proandroiddev.com/from-rxjava-to-kotlin-flow-backpressure-d1fb91e6dea8&#34;&gt;Backpressure&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://proandroiddev.com/from-rxjava-to-kotlin-flow-error-handling-da1f6a4f2708&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/original-proandroiddev-green#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;Error handling is fundamental in reactive programming. Reactive streams might fail with exception and propagate it as an event downstream notifying consumers on the error that happened.&#xA;As in previous articles, we’ll try to compare RxJava and Kotlin Flow error handling mechanisms. This might help us to migrate existing code from RxJava to Kotlin Flow and also understand how to properly use Kotlin Flow.&lt;/p&gt;</description>
    </item>
    <item>
      <title>From RxJava to Kotlin Flow: Backpressure</title>
      <link>https://krossovochkin.com/posts/2020_02_06_from_rxjava_to_kotlin_flow_backpressure/</link>
      <pubDate>Thu, 06 Feb 2020 00:00:00 +0000</pubDate>
      <guid>https://krossovochkin.com/posts/2020_02_06_from_rxjava_to_kotlin_flow_backpressure/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://proandroiddev.com/from-rxjava-to-kotlin-flow-backpressure-d1fb91e6dea8&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/original-proandroiddev-green#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://androidweekly.net/issues/issue-400&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/androidweekly-400-blue#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://proandroiddev.com/proandroiddev-digest-15-b467005869ce&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/proandroiddevdigest-15-green#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Disclaimer&#xA;This article unfortunately is not that dive deep (because of complexity of internals of coroutines), but instead trying to compare RxJava and Kotlin Flow mostly as black box with trying to find out differences in behavior and how to migrate from RxJava with its backpressure solution to Kotlin Flow.&#xA;Hopefully this article will give you direction on where to look at if you decide to migrate to Kotlin Flow.&lt;/p&gt;</description>
    </item>
    <item>
      <title>From RxJava 2 to Kotlin Flow: Threading</title>
      <link>https://krossovochkin.com/posts/2020_01_25_from_rxjava_2_to_kotlin_flow_threading/</link>
      <pubDate>Sat, 25 Jan 2020 00:00:00 +0000</pubDate>
      <guid>https://krossovochkin.com/posts/2020_01_25_from_rxjava_2_to_kotlin_flow_threading/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://images.unsplash.com/photo-1552034412-443022194b52?ixlib=rb-1.2.1&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1357&amp;amp;q=80&#34; alt=&#34;Source&#34;&gt;&lt;em&gt;&lt;a href=&#34;https://unsplash.com/photos/vyyVbUOYNPc&#34;&gt;Source&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://proandroiddev.com/from-rxjava-2-to-kotlin-flow-threading-8618867e1955&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/original-proandroiddev-green#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://androidweekly.net/issues/issue-398&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/androidweekly-398-blue#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://proandroiddev.com/proandroiddev-digest-14-b7247f25292f&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/proandroiddevdigest-14-green#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;For a long time RxJava was undisputed leader for reactive solutions on Android, though with Kotlin expansion and introducing cold streams (Flow) seems situation might be rapidly changing in the coming years.&#xA;Though reactive programming is not related to threading in the first place, concurrency and parallelism are very important anyway.&#xA;In this article we’ll try to make short recap on threading in RxJava 2 (with some basic caveats on its usage) and then take a look at how threading works in Kotlin Flow, so if anyone would like to migrate their code without affecting functionality it would be nice and smooth.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Operator fusion in RxJava 2</title>
      <link>https://krossovochkin.com/posts/2019_11_02_operator_fusion_in_rxjava_2/</link>
      <pubDate>Sat, 02 Nov 2019 00:00:00 +0000</pubDate>
      <guid>https://krossovochkin.com/posts/2019_11_02_operator_fusion_in_rxjava_2/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://proandroiddev.com/operator-fusion-in-rxjava-2-dcd6612cffae&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/original-proandroiddev-green#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://androidweekly.net/issues/issue-386&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/androidweekly-386-blue#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;RxJava is a very powerful library, though it has some issues as well. Specifically performance and memory issues, which come from problems library tries to solve and how the solution is designed from technical perspective.&#xA;In order to minimize overhead in RxJava there are a number of optimizations, which are called “operator fusion”. And we’ll talk about them in this article.&#xA;But first let’s recap how RxJava reactive types work and what issues they have.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Throttling in RxJava 2</title>
      <link>https://krossovochkin.com/posts/2019_06_24_throttling_in_rxjava_2/</link>
      <pubDate>Mon, 24 Jun 2019 00:00:00 +0000</pubDate>
      <guid>https://krossovochkin.com/posts/2019_06_24_throttling_in_rxjava_2/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://proandroiddev.com/throttling-in-rxjava-2-d640ea5f7bf1&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/original-proandroiddev-green#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;I don’t know for what reason but I see from time to time same misunderstanding on different throttle operators in RxJava. Usually nobody says about throttle, instead by default everyone says that debounce can be used. Especially using debounce to avoid multiple clicks on buttons is commonly suggested, which I believe is a bad UX (some examples &lt;a href=&#34;https://www.aanandshekharroy.com/articles/2018-01/rxjava-flowables&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;https://stackoverflow.com/a/48168316/1533933&#34;&gt;here&lt;/a&gt;). Let’s finally look at available options in RxJava and find out when it is better to use what.&lt;/p&gt;</description>
    </item>
    <item>
      <title>RxJava Observable to Single</title>
      <link>https://krossovochkin.com/posts/2019_05_27_rxjava_observable_to_single/</link>
      <pubDate>Mon, 27 May 2019 00:00:00 +0000</pubDate>
      <guid>https://krossovochkin.com/posts/2019_05_27_rxjava_observable_to_single/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://proandroiddev.com/rxjava-observable-to-single-49c2a14da625&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/original-proandroiddev-green#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://androidweekly.net/issues/issue-364&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/androidweekly-364-blue#badge&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;Transforming Single to Observable is simple, as Single satisfies Observable’s contract. Just call single.toObservable() and you’re good. But transforming Observable to Single is not that simple: if it happens that Observable emits exactly one value and completes (or terminates with error without emitting values) then it is pretty straightforward, otherwise one need to set up some additional rules.&lt;/p&gt;&#xA;&lt;p&gt;In RxJava there are a number of operators for transforming Observable to Single:&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
