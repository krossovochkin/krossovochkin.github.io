<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>From RxJava to Kotlin Flow: Throttling :: Krossovochkin — Android Developer</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Source
 This post is part of series of comparing RxJava to Kotlin Flow. Previous articles were about Threading, Backpressure, Error Handling, Stream Types
  
It is advised to take a look at the overview of Throttling operators in RxJava before reading this article: Throttling in RxJava 2
Introduction Throttling is also one of the essential features of reactive programming. Streams might emit more values than we’re expecting to receive, so ability to limit number of events in a stream is very important." />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://krossovochkin.github.io/posts/from_rxjava_to_kotlin_flow_throttling_ed1778847619/" />




<link rel="stylesheet" href="https://krossovochkin.github.io/assets/style.css">

  <link rel="stylesheet" href="https://krossovochkin.github.io/assets/yellow.css">






<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://krossovochkin.github.io/img/apple-touch-icon-144-precomposed.png">

  <link rel="shortcut icon" href="https://krossovochkin.github.io/img/favicon/yellow.png">



<meta name="twitter:card" content="summary" />

  <meta name="twitter:site" content="krossovochkin" />

<meta name="twitter:creator" content="krossovochkin" />


<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="From RxJava to Kotlin Flow: Throttling :: Krossovochkin">
<meta property="og:description" content="Comparing Throttling operators in RxJava and Kotlin Flow" />
<meta property="og:url" content="https://krossovochkin.github.io/posts/from_rxjava_to_kotlin_flow_throttling_ed1778847619/" />
<meta property="og:site_name" content="From RxJava to Kotlin Flow: Throttling" />

  <meta property="og:image" content="https://krossovochkin.github.io/">

<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">


  <meta property="article:published_time" content="2020-03-02 00:00:00 &#43;0000 UTC" />












</head>
<body class="">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    Krossovochkin
  </div>
</a>

    </div>
    <div class="menu-trigger">menu</div>
  </div>
  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About me</a></li>
        
      
        
          <li><a href="/">Posts</a></li>
        
      
      
    

    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About me</a></li>
      
    
      
        <li><a href="/">Posts</a></li>
      
    
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="https://krossovochkin.github.io/posts/from_rxjava_to_kotlin_flow_throttling_ed1778847619/">From RxJava to Kotlin Flow: Throttling</a></h1>
  <div class="post-meta">
    
      <span class="post-date">
        2020-03-02 
      </span>
    
    
    <span class="post-author">::
      Vasya Drobushkov
    </span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="https://krossovochkin.github.io/tags/rxjava/">rxjava</a>&nbsp;
    
    #<a href="https://krossovochkin.github.io/tags/rxjava2/">rxjava2</a>&nbsp;
    
    #<a href="https://krossovochkin.github.io/tags/kotlin/">kotlin</a>&nbsp;
    
    #<a href="https://krossovochkin.github.io/tags/kotlin-flow/">kotlin flow</a>&nbsp;
    
    #<a href="https://krossovochkin.github.io/tags/flow/">flow</a>&nbsp;
    
    #<a href="https://krossovochkin.github.io/tags/throttling/">throttling</a>&nbsp;
    
  </span>
  

  

  

  <div class="post-content"><div>
        <p><img src="https://images.unsplash.com/photo-1538474705339-e87de81450e8?ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1357&amp;q=80" alt="Source"><em><a href="https://unsplash.com/photos/scUBcasSvbE">Source</a></em></p>
<blockquote>
<p>This post is part of series of comparing RxJava to Kotlin Flow. Previous articles were about <a href="https://proandroiddev.com/from-rxjava-2-to-kotlin-flow-threading-8618867e1955">Threading</a>, <a href="https://proandroiddev.com/from-rxjava-to-kotlin-flow-backpressure-d1fb91e6dea8">Backpressure</a>, <a href="https://proandroiddev.com/from-rxjava-to-kotlin-flow-error-handling-da1f6a4f2708">Error Handling,</a> <a href="https://proandroiddev.com/from-rxjava-to-kotlin-flow-stream-types-7916be6cabc2">Stream Types</a></p>
</blockquote>
<p><a href="https://proandroiddev.com/from-rxjava-to-kotlin-flow-throttling-ed1778847619"><img src="https://img.shields.io/badge/original-proandroiddev-green#badge" alt=""></a> <a href="https://proandroiddev.com/proandroiddev-digest-17-d52bc575edb6"><img src="https://img.shields.io/badge/proandroiddevdigest-17-green#badge" alt=""></a></p>
<p>It is advised to take a look at the overview of Throttling operators in RxJava before reading this article:
<a href="https://proandroiddev.com/throttling-in-rxjava-2-d640ea5f7bf1"><strong>Throttling in RxJava 2</strong></a></p>
<h2 id="introduction">Introduction<a href="#introduction" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Throttling is also one of the essential features of reactive programming. Streams might emit more values than we’re expecting to receive, so ability to limit number of events in a stream is very important.
Most common place where it applies is handling UI events. Examples of usage might be handling button clicks (to not allow double clicks), usage with search view when we’d like to wait for user to stop typing before querying some data and so on.
In this article we’ll try to compare throttling operators in RxJava and Kotlin Flow.</p>
<h2 id="comparison">Comparison<a href="#comparison" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<h3 id="setup">Setup<a href="#setup" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Before we start as before we’ll start from some setup.
We’ll have stream with many events, which are emitted with delays (after previous) of 90, 90, 1010, 1010, 2000, 90, 1010, 80 milliseconds.
It might be shown as such (scale doesn’t apply):</p>
<p><img src="../../img/1__IwO2_7swxHkAaKBq-Z2NQ.png" alt=""></p>
<p>For RxJava we’ll have the following observable:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">observable</span>(): Observable&lt;Int&gt; {
    <span style="color:#66d9ef">return</span> Observable.create { emitter -&gt;
        emitter.onNext(<span style="color:#ae81ff">1</span>)
        Thread.sleep(<span style="color:#ae81ff">90</span>)
        emitter.onNext(<span style="color:#ae81ff">2</span>)
        Thread.sleep(<span style="color:#ae81ff">90</span>)
        emitter.onNext(<span style="color:#ae81ff">3</span>)
        Thread.sleep(<span style="color:#ae81ff">1010</span>)
        emitter.onNext(<span style="color:#ae81ff">4</span>)
        Thread.sleep(<span style="color:#ae81ff">1010</span>)
        emitter.onNext(<span style="color:#ae81ff">5</span>)
        Thread.sleep(<span style="color:#ae81ff">2000</span>)
        emitter.onNext(<span style="color:#ae81ff">6</span>)
        Thread.sleep(<span style="color:#ae81ff">90</span>)
        emitter.onNext(<span style="color:#ae81ff">7</span>)
        Thread.sleep(<span style="color:#ae81ff">1010</span>)
        emitter.onNext(<span style="color:#ae81ff">8</span>)
        Thread.sleep(<span style="color:#ae81ff">80</span>)
        emitter.onNext(<span style="color:#ae81ff">9</span>)
        emitter.onComplete()
    }
}
</code></pre></div><p>And for Kotlin Flow:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">myFlow</span>(): Flow&lt;Int&gt; {
    <span style="color:#66d9ef">return</span> flow {
        emit(<span style="color:#ae81ff">1</span>)
        delay(<span style="color:#ae81ff">90</span>)
        emit(<span style="color:#ae81ff">2</span>)
        delay(<span style="color:#ae81ff">90</span>)
        emit(<span style="color:#ae81ff">3</span>)
        delay(<span style="color:#ae81ff">1010</span>)
        emit(<span style="color:#ae81ff">4</span>)
        delay(<span style="color:#ae81ff">1010</span>)
        emit(<span style="color:#ae81ff">5</span>)
        delay(<span style="color:#ae81ff">2000</span>)
        emit(<span style="color:#ae81ff">6</span>)
        delay(<span style="color:#ae81ff">90</span>)
        emit(<span style="color:#ae81ff">7</span>)
        delay(<span style="color:#ae81ff">1010</span>)
        emit(<span style="color:#ae81ff">8</span>)
        delay(<span style="color:#ae81ff">80</span>)
        emit(<span style="color:#ae81ff">9</span>)
    }
}
</code></pre></div><p>In order to test various throttling strategies we’ll have the following test functions parametrized by operators.</p>
<p>For RxJava:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">testObservable</span>(<span style="color:#66d9ef">operator</span>: Observable&lt;Int&gt;.() -&gt; Observable&lt;Int&gt;) {

    <span style="color:#66d9ef">val</span> latch = CountDownLatch(<span style="color:#ae81ff">1</span>)
    <span style="color:#66d9ef">val</span> result = StringBuffer()

    observable()
        .<span style="color:#66d9ef">operator</span>()
        .doOnComplete { latch.countDown() }
        .subscribeOn(computation())
        .subscribe { result.append(it).append(<span style="color:#e6db74">&#34; &#34;</span>) }

    latch.await()
    println(<span style="color:#e6db74">&#34;$result&#34;</span>)
}
</code></pre></div><p>And for Kotlin Flow:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">testFlow</span>(<span style="color:#66d9ef">operator</span>: Flow&lt;Int&gt;.() -&gt; Flow&lt;Int&gt;) {

    <span style="color:#66d9ef">val</span> latch = CountDownLatch(<span style="color:#ae81ff">1</span>)
    <span style="color:#66d9ef">val</span> result = StringBuffer()

    CoroutineScope(Job() + Dispatchers.Default).launch {
        myFlow()
            .<span style="color:#66d9ef">operator</span>()
            .onCompletion { latch.countDown() }
            .collect { result.append(it).append(<span style="color:#e6db74">&#34; &#34;</span>) }
    }

    latch.await()
    println(<span style="color:#e6db74">&#34;$result&#34;</span>)
}
</code></pre></div><p>In all the examples we’ll use timeout of 1000 milliseconds.</p>
<h3 id="debounce">Debounce<a href="#debounce" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>First throttling operator which is useful for search queries (waits until some timeout expired before emitting value) is debounce.
If we show expected result on a plot we’ll see the following:</p>
<p><img src="../../img/1_bPC_0DVfI7FQkSiVmCkHvw.png" alt=""></p>
<p>So, in short after event received we start timer. If new event comes when timer is active, we restart timer. If timer expired then we emit latest item emitted.</p>
<p>So, we expect here to get events from 3, 4, 5, 7 and 9 events (with all other events throttled).</p>
<p>To achieve such result in RxJava we’ll need to use debounce operator:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">testObservable { debounce(<span style="color:#ae81ff">1000</span>, TimeUnit.MILLISECONDS) }
</code></pre></div><p>With Kotlin Flow we’ll have to use same operator:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">testFlow { debounce(<span style="color:#ae81ff">1000</span>) }
</code></pre></div><h3 id="throttlelast">ThrottleLast<a href="#throttlelast" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>This mode starts timer with predefined interval and emit last emitted value when timer expires. After that it will restart timer.</p>
<p><img src="../../img/1_lLXqIZ9_Tysd1V3z3i9hsg.png" alt=""></p>
<p>Here we expect values of 3, 4, 5 and 7 to be emitted.
Value 9 won’t be emitted in this case because stream would be finished before timer expired.</p>
<p>To get such behavior we’ll have to use throttleLast in RxJava and sample in Kotlin Flow:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">testObservable { throttleLast(<span style="color:#ae81ff">1000</span>, TimeUnit.MILLISECONDS) }
testFlow { sample(<span style="color:#ae81ff">1000</span>) }
</code></pre></div><h3 id="throttlefirst">ThrottleFirst<a href="#throttlefirst" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>This operator is useful to avoid double-clicks on buttons. It emits very first item and starts timer. All items which will come before timer expired will be discarded.</p>
<p><img src="../../img/1_x66TBAX2--F3XtxX54MfJQ.png" alt=""></p>
<p>Here we would expect to receive events 1, 4, 5, 6, 8.</p>
<p>In RxJava we’ll use throttleFirst operator:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">testObservable { throttleFirst(<span style="color:#ae81ff">1000</span>, TimeUnit.MILLISECONDS) }
</code></pre></div><p>In Kotlin Flow though there is no such operator, so we’ll have to write some implementation by our own. The implementation might look like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> &lt;T&gt; <span style="color:#a6e22e">Flow</span>&lt;T&gt;.throttleFirstJava(periodMillis: Long): Flow&lt;T&gt; {
    require(periodMillis &gt; <span style="color:#ae81ff">0</span>) { <span style="color:#e6db74">&#34;period should be positive&#34;</span> }
    <span style="color:#66d9ef">return</span> flow {
        <span style="color:#66d9ef">var</span> lastTime = <span style="color:#ae81ff">0L</span>
        collect { value -&gt;
            <span style="color:#66d9ef">val</span> currentTime = System.currentTimeMillis()
            <span style="color:#66d9ef">if</span> (currentTime - lastTime &gt;= periodMillis) {
                lastTime = currentTime
                emit(value)
            }
        }
    }
}
</code></pre></div><p>And the usage will be:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">testFlow { throttleFirstJava(<span style="color:#ae81ff">1000</span>) }
</code></pre></div><h3 id="throttlelatest">ThrottleLatest<a href="#throttlelatest" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>ThrottleLatest can be seen as some combination of throttleFirst and throttleLast. It will emit first item and start timer. Then when timer expires it would emit latest emitted value. But it won’t restart timer before new item emitted.</p>
<p><img src="../../img/1_rQUZS4HK-o5WtTut555gsA.png" alt=""></p>
<p>Here we expect values of 1, 3, 4, 5, 6, 7 to be emitted. Here value of 8 won’t be emitted because timer hasn’t expired after 7. And 9 won’t be emitted because stream completed before timer expired.</p>
<p>In RxJava we’ll use throttleLatest operator:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">testObservable { throttleLatest(<span style="color:#ae81ff">1000</span>, TimeUnit.MILLISECONDS) }
</code></pre></div><p>In Kotlin Flow again there is no such operator, but we can try to write implementation by our own.
Some java version which uses Timer can look like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> &lt;T&gt; <span style="color:#a6e22e">Flow</span>&lt;T&gt;.throttleLatestJava(periodMillis: Long): Flow&lt;T&gt; {
    <span style="color:#66d9ef">return</span> channelFlow {
        <span style="color:#66d9ef">var</span> lastValue: T?
        <span style="color:#66d9ef">var</span> timer: Timer? = <span style="color:#66d9ef">null</span>
        onCompletion { timer<span style="color:#f92672">?.</span>cancel() }
        collect { value -&gt;
            lastValue = value

            <span style="color:#66d9ef">if</span> (timer == <span style="color:#66d9ef">null</span>) {
                timer = Timer()
                timer<span style="color:#f92672">?.</span>scheduleAtFixedRate(
                    <span style="color:#66d9ef">object</span> <span style="color:#960050;background-color:#1e0010">: </span><span style="color:#a6e22e">TimerTask</span>() {
                        <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">run</span>() {
                            <span style="color:#66d9ef">val</span> value = lastValue
                            lastValue = <span style="color:#66d9ef">null</span>
                            <span style="color:#66d9ef">if</span> (value != <span style="color:#66d9ef">null</span>) {
                                launch {
                                    send(value <span style="color:#66d9ef">as</span> T)
                                }
                            } <span style="color:#66d9ef">else</span> {
                                timer<span style="color:#f92672">?.</span>cancel()
                                timer = <span style="color:#66d9ef">null</span>
                            }
                        }
                    },
                    <span style="color:#ae81ff">0</span>,
                    periodMillis
                )
            }
        }
    }
}
</code></pre></div><p>It is quite big and uses Timer, which is based on Thread, so might not be good to be used in conjunction with coroutines.</p>
<p>We might want to write some version which uses coroutines only (similar to debounce):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">@ExperimentalCoroutinesApi
<span style="color:#66d9ef">fun</span> &lt;T&gt; <span style="color:#a6e22e">Flow</span>&lt;T&gt;.throttleLatestKotlin(periodMillis: Long): Flow&lt;T&gt; {
    require(periodMillis &gt; <span style="color:#ae81ff">0</span>) { <span style="color:#e6db74">&#34;period should be positive&#34;</span> }

    <span style="color:#66d9ef">return</span> channelFlow {
        <span style="color:#66d9ef">val</span> done = Any()
        <span style="color:#66d9ef">val</span> values = produce(capacity = Channel.CONFLATED) {
            collect { value -&gt; send(value) }
        }

        <span style="color:#66d9ef">var</span> lastValue: Any? = <span style="color:#66d9ef">null</span>
        <span style="color:#66d9ef">val</span> ticker = Ticker(periodMillis)
        <span style="color:#66d9ef">while</span> (lastValue !== done) {
            select&lt;Unit&gt; {
                values.onReceiveOrNull {
                    <span style="color:#66d9ef">if</span> (it == <span style="color:#66d9ef">null</span>) {
                        ticker.cancel()
                        lastValue = done
                    } <span style="color:#66d9ef">else</span> {
                        lastValue = it
                        <span style="color:#66d9ef">if</span> (!ticker.isStarted) {
                            ticker.start(<span style="color:#66d9ef">this</span>@channelFlow)
                        }
                    }

                }

                ticker.getTicker().onReceive {
                    <span style="color:#66d9ef">if</span> (lastValue !== <span style="color:#66d9ef">null</span>) {
                        <span style="color:#66d9ef">val</span> value = lastValue
                        lastValue = <span style="color:#66d9ef">null</span>
                        send(value <span style="color:#66d9ef">as</span> T)
                    } <span style="color:#66d9ef">else</span> {
                        ticker.stop()
                    }
                }
            }
        }
    }
}
</code></pre></div><p>And here we’ll have to create special Ticker implementation:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Ticker</span>(<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">val</span> delay: Long) {

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> channel: ReceiveChannel&lt;Unit&gt; = Channel()

    <span style="color:#66d9ef">var</span> isStarted: Boolean = <span style="color:#66d9ef">false</span>
        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">set</span>

    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">getTicker</span>(): ReceiveChannel&lt;Unit&gt; {
        <span style="color:#66d9ef">return</span> channel
    }

    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">start</span>(scope: CoroutineScope) {
        isStarted = <span style="color:#66d9ef">true</span>
        channel.cancel()
        channel = scope.produce(capacity = <span style="color:#ae81ff">0</span>) {
            <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>) {
                channel.send(Unit)
                delay(delay)
            }
        }
    }

    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">stop</span>() {
        isStarted = <span style="color:#66d9ef">false</span>
        channel.cancel()
        channel = Channel()
    }

    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">cancel</span>() {
        isStarted = <span style="color:#66d9ef">false</span>
        channel.cancel()
    }
}
</code></pre></div><p>Usages of such operators will look like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">testFlow { throttleLatestKotlin(<span style="color:#ae81ff">1000</span>) }
testFlow { throttleLatestJava(<span style="color:#ae81ff">1000</span>) }
</code></pre></div><p>Though because of complexity and possible issues with threading I’d not recommend to use such operators in production code. I hope we’ll have some operators which will be inside standard library.</p>
<h2 id="conslusion">Conslusion<a href="#conslusion" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>As seen above in Kotlin Flow we have only 2 out of 4 operators for throttling. Though throttleFirst implementation is simple and straightforward, implementation of throttleLatest might be error-prone and it is better to wait until implementation is added to standard library.</p>
<p>Also need to draw attention that our own throttleFirst implementation would not respect TestCoroutineScope.</p>
<p>Lacking of operators in Kotlin Flow might lead to not so easy migration from RxJava. 
Other than that it is good that we have debounce.</p>
<p>Hope this article was useful for you. If somebody wants to play with the sample — it can be found in <a href="https://gist.github.com/krossovochkin/3c7fcda19e732e7451831e97b165568f">this gist</a>.</p>
<p>Happy coding!</p>

      </div></div>

  
  
<div class="pagination">
    <div class="pagination__title">
        <span class="pagination__title-h">Read other posts</span>
        <hr />
    </div>
    <div class="pagination__buttons">
        
        <span class="button previous">
            <a href="https://krossovochkin.github.io/posts/from_rxjava_to_kotlin_flow_testing_42f1641d8433/">
                <span class="button__icon">←</span>
                <span class="button__text">From RxJava to Kotlin Flow: Testing</span>
            </a>
        </span>
        
        
        <span class="button next">
            <a href="https://krossovochkin.github.io/posts/from_rxjava_to_kotlin_flow_stream_types_7916be6cabc2/">
                <span class="button__text">From RxJava to Kotlin Flow: Stream Types</span>
                <span class="button__icon">→</span>
            </a>
        </span>
        
    </div>
</div>

  

  

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">
        <span>© 2020 Vasya Drobushkov</span>
    
        <span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
      </div>
  </div>
  <div class="footer__inner">
    <div class="copyright copyright--user">
      <a href="https://www.facebook.com/vasya.drobushkov">Facebook</a><a href="https://twitter.com/krossovochkin">Twitter</a>
    </div>
  </div>
</footer>

<script src="https://krossovochkin.github.io/assets/main.js"></script>
<script src="https://krossovochkin.github.io/assets/prism.js"></script>





  
</div>

</body>
</html>
