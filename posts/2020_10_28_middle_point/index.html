<!DOCTYPE html>
<html lang="en">
    
    


    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<!-- Enable responsiveness on mobile devices -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.78.2" />

    
    
    

<title>Middle Point â€¢ Vasya Drobushkov</title>


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Middle Point"/>
<meta name="twitter:description" content="Introduction Working with numbers in programming never was a simple thing. In math, we deal with various sets of numbers - whole numbers, rational, complex. All these sets are infinite - that means that for any number we can find another smaller one and one which is bigger. In programming when we work with numbers we deal with some subset of these sets - that many that can be represented with a given amount of bits."/>

<meta property="og:title" content="Middle Point" />
<meta property="og:description" content="Introduction Working with numbers in programming never was a simple thing. In math, we deal with various sets of numbers - whole numbers, rational, complex. All these sets are infinite - that means that for any number we can find another smaller one and one which is bigger. In programming when we work with numbers we deal with some subset of these sets - that many that can be represented with a given amount of bits." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://krossovochkin.com/posts/2020_10_28_middle_point/" />
<meta property="article:published_time" content="2020-10-28T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-10-28T00:00:00+00:00" /><meta property="og:site_name" content="Krossovochkin" />


    


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/androidstudio.min.css">








<link rel="stylesheet" href="/scss/hyde-hyde.adf8a0af011d3afb07ed907ad3295e1c99f49503bc91d395e38dc3f8dfdf4900.css" integrity="sha256-rfigrwEdOvsH7ZB60yleHJn0lQO8kdOV443D&#43;N/fSQA=">


<link rel="stylesheet" href="/scss/print.2744dcbf8a0b2e74f8a50e4b34e5f441be7cf93cc7de27029121c6a09f9e77bc.css" integrity="sha256-J0Tcv4oLLnT4pQ5LNOX0Qb58&#43;TzH3icCkSHGoJ&#43;ed7w=" media="print">



    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <!-- Icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
    <link rel="shortcut icon" href="/favicon.png">
    
    

</head>


    <body class="theme-base-0a ">
    
<div class="sidebar">
  <div class="container ">
    <div class="sidebar-about">
      <span class="site__title">
        <a href="https://krossovochkin.com/">
        
          Vasya Drobushkov
        
        </a>
      </span>
      
        
        
        
        <div class="author-image">
          <img src="https://krossovochkin.com/../img/avatar.png" alt="Author Image" class="img--circle img--headshot element--center">
        </div>
        
      
      
      <p class="site__description">
        
      </p>
    </div>
    <div class="collapsible-menu">
      <input type="checkbox" id="menuToggle">
      <label for="menuToggle">Vasya Drobushkov</label>
      <div class="menu-content">
        <div>
	<ul class="sidebar-nav">
		 
		 
			 
				<li>
					<a href="/posts/">
						<span>Posts</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/about/">
						<span>About</span>
					</a>
				</li>
			 
		
	</ul>
</div>

        <section class="social">
	
	<a href="https://twitter.com/krossovochkin" rel="me"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a>
	
	
	
	<a href="https://facebook.com/vasya.drobushkov" rel="me"><i class="fab fa-facebook-f"></i></a>
	
	
	<a href="https://github.com/krossovochkin" rel="me"><i class="fab fa-github fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	
	
	
	<a href="https://linkedin.com/in/vasyadrobushkov" rel="me"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a>
	
	
	
	<a href="https://stackoverflow.com/users/1533933/krossovochkin" rel="me"><i class="fab fa-stack-overflow fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	
	
	
	
	
	
	
</section>

      </div>
    </div>
    
<div class="copyright">
  &copy; 2019 - 2020 Vasya Drobushkov
  
    <a href="https://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0</a>
  
</div>



  </div>
</div>

        <div class="content container">
            
    
<article>
  <header>
    <h1>Middle Point</h1>
    
    
<div class="post__meta">
    
    
      <i class="fas fa-calendar-alt"></i> Oct 28, 2020
    
    
    
    
    
      
      
          <br/>
           <i class="fas fa-tags"></i>
          
          <a class="badge badge-tag" href="/tags/programming">programming</a>
          
      
    
    
    <br/>
    <i class="fas fa-clock"></i> 11 min read
</div>


  </header>
  
  
  <div class="post">
    <h3 id="introduction">Introduction</h3>
<p>Working with numbers in programming never was a simple thing. In math, we deal with various sets of numbers - whole numbers, rational, complex. All these sets are infinite - that means that for any number we can find another smaller one and one which is bigger. In programming when we work with numbers we deal with some subset of these sets - that many that can be represented with a given amount of bits.
When we want to work with whole numbers we can use e.g. Integer, which are the numbers being able to be represented usually with 4 bits. For floating-point numbers - say Double - it is 8 bits. There is no plus or minus infinity (in Double there are +/- infinity, though they are used for special cases).</p>
<p>Let&rsquo;s look at a simple problem: given start and end number - calculate number which is in the middle. That means that we need to find such a number, which distance both to start and end will be the same.<br>
In math this is a simple problem: <code>(a + b) / 2</code> is the number. Let&rsquo;s look at what difficulties we&rsquo;ll face while writing such a program.<br>
We&rsquo;ll start with Integers first and then take a look at floating-point numbers.</p>
<h3 id="design-api">Design API</h3>
<p>We&rsquo;d like to have a function that takes two numbers as parameters returning the middle point as a result. That means that for Integers we might have:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">middle</span>(start: Int, end: Int): Int
</code></pre></div><p>For Double:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">middle</span>(start Double, end: Double): Double 
</code></pre></div><p>And in general, if we would like to work with any number:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">middle</span>(start: Number, end: Number): Number
</code></pre></div><h3 id="analyze-solution-existence">Analyze solution existence</h3>
<p>As said before - we&rsquo;re dealing with a subset of numbers in programming. Therefore the first question we&rsquo;d like to answer is whether we&rsquo;ll have a solution for any given set of numbers.<br>
Here we have three situations:</p>
<ul>
<li>start is greater than the end. We can safely assume that start should not be greater than the end. In such a case no solution exists, because our logical rule is broken. That means that here we can throw an exception.<br>
Let&rsquo;s write a test for this:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#a6e22e">@Test</span>(expected = IllegalArgumentException<span style="color:#f92672">::</span><span style="color:#66d9ef">class</span>)
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">`if start greater than end then throws exception`</span>() {
	middle(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">4</span>)
}
</code></pre></div><ul>
<li>start is equal to end. In such a case middle both points are in the same place - and the middle will be there as well. Therefore we can return either start or end as a result.<br>
This can be handled by this test case:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#a6e22e">@Test</span>
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">`if start == end then start`</span>() {
	assertEquals(<span style="color:#ae81ff">5</span>, middle(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">5</span>))
}
</code></pre></div><ul>
<li>start is less than the end. Here we can apply our general logic of calculating the middle point.</li>
</ul>
<p>With this our initial setup for a function will be:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">middle</span>(start: Int, end: Int): Int {
	<span style="color:#66d9ef">if</span> (start &gt; end) <span style="color:#66d9ef">throw</span> IllegalArgumentException()
	<span style="color:#66d9ef">if</span> (start <span style="color:#f92672">==</span> end) <span style="color:#66d9ef">return</span> start
	<span style="color:#f92672">..</span>.
}
</code></pre></div><h3 id="integer-naive-approach">Integer naive approach</h3>
<p>An additional case which we should cover with Integer numbers is a case when we have two numbers with odd distance. Assume we have <code>start = 3</code> and <code>end = 6</code>. The correct middle point here would be <code>4.5</code>. But it is not possible to represent such a number as Integer.<br>
To cover that case we&rsquo;ll introduce an exception - in such cases we&rsquo;ll return closest smaller to the real middle point number.<br>
This will be covered with:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#a6e22e">@Test</span>
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">`if distance is odd then returns closest smaller`</span>() {
	assertEquals(<span style="color:#ae81ff">4</span>, middle(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">6</span>))
}
</code></pre></div><p>For any other pair of points, we&rsquo;ll be able to have a solution. If <code>start</code> and <code>end</code> can be represented as Integers (they are in the subset of whole numbers which can be represented as Integer) middle point will be between them and that means solution also will be represented as Integer without issues.</p>
<p>The naive approach would be to apply our math knowledge, we&rsquo;ll write our function body:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">middle</span>(start: Int, end: Int): Int {
	<span style="color:#f92672">..</span>.
	<span style="color:#66d9ef">return</span> (start + end) / <span style="color:#ae81ff">2</span>
}
</code></pre></div><p>But this would be incorrect because if <code>start = 1</code> and <code>end = Int.MAX_VALUE</code> then <code>start + end</code> overflows and the result will be negative.</p>
<h3 id="integer-handling-overflow">Integer handling overflow</h3>
<p>That means that whenever we design a function that works with numbers, we need to consider that not all whole numbers can be represented as Integer. Specifically, we need to carefully take a look at boundaries.<br>
For handling this there is a good trick:</p>
<pre><code>(a + b) / 2 = a / 2 + b / 2 = a - a / 2 + b / 2 = a + (b - a) / 2
</code></pre><p>With a simple trick, we now avoid the sum of big numbers therefore our case with <code>start = 1</code> and <code>end = Int.MAX_VALUE</code> now works correctly. So, our function will be:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">middle</span>(start: Int, end: Int): Int {
	<span style="color:#f92672">..</span>.
	<span style="color:#66d9ef">return</span> start + (end - start) / <span style="color:#ae81ff">2</span>
}
</code></pre></div><p>But now we have subtraction, which means we need to pay attention to <code>Int.MIN_VALUE</code> as well. What if we have <code>start = Int.MIN_VALUE</code> and <code>end = 5</code>. Now we have an overflow again.</p>
<p>After considering all of this we come up with a solution: depending on whether start and end have same sign or different, we&rsquo;ll use different formula. And the function will be:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">middle</span>(start: Int, end: Int): Int {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">when</span> {
        start &gt; end <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">throw</span> IllegalArgumentException()
        start <span style="color:#f92672">==</span> end <span style="color:#f92672">-&gt;</span> start
        start &lt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> end &gt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">-&gt;</span> (start + end) / <span style="color:#ae81ff">2</span>
        <span style="color:#66d9ef">else</span> <span style="color:#f92672">-&gt;</span> start + (end - start) / <span style="color:#ae81ff">2</span>
    }
}
</code></pre></div><p>And the set of tests:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#a6e22e">@Test</span>
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">`if start greater than 0 and end greater than 0 and no overflow`</span>() {
	assertEquals(<span style="color:#ae81ff">6</span>, middle(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">11</span>))
}

<span style="color:#a6e22e">@Test</span>
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">`if start greater than 0 and end greater than 0 and has overflow`</span>() {
	assertEquals(Int.MAX_VALUE - <span style="color:#ae81ff">1</span>, middle(Int.MAX_VALUE - <span style="color:#ae81ff">2</span>, Int.MAX_VALUE))
}

<span style="color:#a6e22e">@Test</span>
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">`if start less than 0 and end less than 0 and no overflow`</span>() {
	assertEquals(-<span style="color:#ae81ff">6</span>, middle(-<span style="color:#ae81ff">11</span>, -<span style="color:#ae81ff">1</span>))
}

<span style="color:#a6e22e">@Test</span>
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">`if start less than 0 and end less than 0 and has overflow`</span>() {
	assertEquals(Int.MIN_VALUE + <span style="color:#ae81ff">1</span>, middle(Int.MIN_VALUE + <span style="color:#ae81ff">1</span>, Int.MIN_VALUE + <span style="color:#ae81ff">2</span>))
}

<span style="color:#a6e22e">@Test</span>
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">`if start less than 0 and end greater than 0 and no overflow`</span>() {
	assertEquals(<span style="color:#ae81ff">1</span>, middle(-<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">6</span>))
}

<span style="color:#a6e22e">@Test</span>
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">`if start less than 0 and end greater than 0 and has overflow`</span>() {
	assertEquals(-<span style="color:#ae81ff">1</span>, middle(Int.MIN_VALUE, Int.MAX_VALUE - <span style="color:#ae81ff">1</span>))
}
</code></pre></div><p>Not as simple as was at first thought.</p>
<h3 id="double-naive-approach">Double naive approach</h3>
<p>Now let&rsquo;s look at Double. Here we can be sure that we&rsquo;ll be able to represent the result correctly for the case when the middle point can&rsquo;t be represented as an Integer because of the decimal part.</p>
<p>Let&rsquo;s just copy-paste our function changing Int to Double:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">middle</span>(start: Double, end: Double): Double {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">when</span> {
        start &gt; end <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">throw</span> IllegalArgumentException()
        start <span style="color:#f92672">==</span> end <span style="color:#f92672">-&gt;</span> start
        start &lt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> end &gt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">-&gt;</span> (start + end) / <span style="color:#ae81ff">2</span>
        <span style="color:#66d9ef">else</span> <span style="color:#f92672">-&gt;</span> start + (end - start) / <span style="color:#ae81ff">2</span>
    }
}
</code></pre></div><p>Are we good? Not really. With floating-point numbers, one should work carefully because of precision. While with Integers it is not possible to represent numbers less than <code>Int.MIN_VALUE</code> and greater than <code>Int.MAX_VALUE</code> and points in between two closest Integer values, with doubles we might not preserve exact numbers in between two points with the required precision.</p>
<p>Consider the following test:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#a6e22e">@Test</span>
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">`double inexact`</span>() {
	assertEquals(<span style="color:#ae81ff">0.45</span>, middle(<span style="color:#ae81ff">0.3</span>, <span style="color:#ae81ff">0.6</span>), <span style="color:#ae81ff">1.0e-17</span>)
}
</code></pre></div><p>The solution should be <code>0.45</code>, but after math applied to Double numbers, there might be an error. And instead of <code>0.45</code>, we&rsquo;ll get <code>0.44999999999999</code>. That is why when doing a comparison we have to add precision. If we take say <code>1.0e-16</code> - test passes. But if we take <code>1.0e-17</code> - it fails, because the result can be represented with the required precision. This is something we should be aware of. Our function will return the best possible result.</p>
<h3 id="double-infinity">Double infinity</h3>
<p>With Double, we not only have <code>Double.MIN_VALUE</code> and <code>Double.MAX_VALUE</code>. Also, we have <code>Double.NEGATIVE_INFINITY</code> and <code>Double.POSITIVE_INFINITY</code>. These are special values and let&rsquo;s look at how our implementation works with them.<br>
But first, let&rsquo;s think about the expected results.</p>
<p>We might say that if start or end is represented as infinity then the result is unknown. We don&rsquo;t know how far we can go with either. So, the simplest thing we can do is to check for these values and, for example, throw an exception.<br>
But also we can do some additional calculations.<br>
For example, if we have <code>start = Double.NEGATIVE_INFINITY</code> and <code>end = Double.NEGATIVE_INFINITY</code>? Our start and end both the same, so it feels that we can return <code>Double.NEGATIVE_INFINITY</code> as a result. Same for <code>Double.POSITIVE_INFINITY</code>. And this case is already covered by our check for <code>start == end</code>.</p>
<p>What about one number is infinity and another is not? Can we assume that result should be infinity as well? I guess so. Because whatever we sum with infinity - the result will be infinity again.</p>
<p>And what about the case when <code>start == Double.NEGATIVE_INFINITY</code> and <code>end == Double.POSITIVE_INFINITY</code>? Here the result is undefined. We don&rsquo;t know what is bigger - negative infinity or positive infinity. We could speculate that result should be <code>0</code>. And probably it is up to a designer of the method. I think that in such a case it is better to throw an exception.</p>
<p>And our set of tests is now should have:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#a6e22e">@Test</span>(expected = IllegalArgumentException<span style="color:#f92672">::</span><span style="color:#66d9ef">class</span>)
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">`double start is negative infinity and end is positive infinity then throws exception`</span>() {
	middle(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY)
}

<span style="color:#a6e22e">@Test</span>
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">`double start is negative infinity and end is not infinity then negative infinity`</span>() {
	assertEquals(Double.NEGATIVE_INFINITY, middle(Double.NEGATIVE_INFINITY, Double.MAX_VALUE), <span style="color:#ae81ff">1.0e-16</span>)
}

<span style="color:#a6e22e">@Test</span>
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">`double start is not infinity and end is positive infinity then positive infinity`</span>() {
	assertEquals(Double.POSITIVE_INFINITY, middle(Double.MIN_VALUE, Double.POSITIVE_INFINITY), <span style="color:#ae81ff">1.0e-16</span>)
}

<span style="color:#a6e22e">@Test</span>
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">`double start == end == negative infinity then negative infinity`</span>() {
	assertEquals(Double.NEGATIVE_INFINITY, middle(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY), <span style="color:#ae81ff">1.0e-16</span>)
}

<span style="color:#a6e22e">@Test</span>
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">`double start == end == positive infinity then positive infinity`</span>() {
	assertEquals(Double.POSITIVE_INFINITY, middle(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY), <span style="color:#ae81ff">1.0e-16</span>)
}
</code></pre></div><p>And our fixed solution for Double now looks like:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">middle</span>(start: Double, end: Double): Double {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">when</span> {
        start <span style="color:#f92672">==</span> Double.NEGATIVE_INFINITY <span style="color:#f92672">&amp;&amp;</span> end <span style="color:#f92672">==</span> Double.POSITIVE_INFINITY <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">throw</span> IllegalArgumentException()
        start &gt; end <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">throw</span> IllegalArgumentException()
        start <span style="color:#f92672">==</span> end <span style="color:#f92672">-&gt;</span> start
        start &lt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> end &gt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">-&gt;</span> (start + end) / <span style="color:#ae81ff">2</span>
        <span style="color:#66d9ef">else</span> <span style="color:#f92672">-&gt;</span> start + (end - start) / <span style="color:#ae81ff">2</span>
    }
}
</code></pre></div><h3 id="double-nan">Double NaN</h3>
<p>There is yet another special value in Double - <code>Double.NaN</code>. Here the solution is simple: if either start or end is <code>Double.NaN</code> then we should throw an exception, as we can&rsquo;t calculate the result.</p>
<p>We add two more test cases:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#a6e22e">@Test</span>(expected = IllegalArgumentException<span style="color:#f92672">::</span><span style="color:#66d9ef">class</span>)
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">`start == NaN then throws exception`</span>() {
	middle(Double.NaN, <span style="color:#ae81ff">1.0</span>)
}

<span style="color:#a6e22e">@Test</span>(expected = IllegalArgumentException<span style="color:#f92672">::</span><span style="color:#66d9ef">class</span>)
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">`end == NaN then throws exception`</span>() {
	middle(<span style="color:#ae81ff">1.0</span>, Double.NaN)
}
</code></pre></div><p>And adjust our function to handle that:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">middle</span>(start: Double, end: Double): Double {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">when</span> {
        start.isNaN() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">throw</span> IllegalArgumentException()
        end.isNaN() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">throw</span> IllegalArgumentException()
        start <span style="color:#f92672">==</span> Double.NEGATIVE_INFINITY <span style="color:#f92672">&amp;&amp;</span> end <span style="color:#f92672">==</span> Double.POSITIVE_INFINITY <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">throw</span> IllegalArgumentException()
        start &gt; end <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">throw</span> IllegalArgumentException()
        start <span style="color:#f92672">==</span> end <span style="color:#f92672">-&gt;</span> start
        start &lt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> end &gt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">-&gt;</span> (start + end) / <span style="color:#ae81ff">2</span>
        <span style="color:#66d9ef">else</span> <span style="color:#f92672">-&gt;</span> start + (end - start) / <span style="color:#ae81ff">2</span>
    }
}
</code></pre></div><p>One thing to note is that it is tempting to make a comparison with <code>start == Double.NaN</code>, but it would be a mistake.<br>
If we look at implementation of <code>isNan</code> method, we&rsquo;ll see the following:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isNaN</span><span style="color:#f92672">(</span><span style="color:#66d9ef">double</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
	<span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>v <span style="color:#f92672">!=</span> v<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><code>Double.NaN</code> is not equal to itself, so <code>start == Double.NaN</code> would be incorrect.</p>
<blockquote>
<p>With Double it is possible to not throw an exception but instead in exceptional cases return <code>Double.NaN</code>. It is again totally acceptable and depends on the API designer&rsquo;s decision.</p>
</blockquote>
<h3 id="number">Number</h3>
<p>Let&rsquo;s say we&rsquo;d like to write a general function for any Number. We have various options:</p>
<ul>
<li>create a separate option for any type of Number (though we wouldn&rsquo;t handle the case with some third party implementations). This way we will check the type of provided number and choose the correct function with some fallback (probably Double or BigDecimal)</li>
<li>create a single version which under the hood will use the broadest type - say BigDecimal. Then the client will convert the result to the required Number implementation. This will give us a single method, though it will be heavier in terms of resources.</li>
</ul>
<p>For simplicity, let&rsquo;s go with the second option.</p>
<p>Here we can apply just something like:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">middle</span>(start: Number, end: Number): Number {
    <span style="color:#66d9ef">if</span> (start <span style="color:#f92672">==</span> end) {
        <span style="color:#66d9ef">return</span> start
    }
    <span style="color:#66d9ef">val</span> a = start.toString().toBigDecimal()
    <span style="color:#66d9ef">val</span> b = end.toString().toBigDecimal()

    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">when</span> {
        a &gt; b <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">throw</span> IllegalArgumentException()
        a &lt; BigDecimal.ZERO <span style="color:#f92672">&amp;&amp;</span> b &gt; BigDecimal.ZERO <span style="color:#f92672">-&gt;</span> (a + b) / <span style="color:#ae81ff">2.</span>toBigDecimal()
        <span style="color:#66d9ef">else</span> <span style="color:#f92672">-&gt;</span> a + (b - a) / <span style="color:#ae81ff">2.</span>toBigDecimal()
    }
}
</code></pre></div><p>First, we&rsquo;ll check for our initial equality to avoid redundant conversion.
Then we first convert numbers to string and then to BigDecimal. We do that to avoid losing information.
Finally, we have our usual checks. Thanks to Kotlin operator overload it looks pretty well with <code>+</code> instead of <code>plus</code>.</p>
<h3 id="conclusion">Conclusion</h3>
<p>In this article, I wanted to show two things. First, that math as we study it at university and math in programming are two different things. In programming, we face additional limitations that we can&rsquo;t ignore. Second that even some small and simple functions require thorough API design. Depending on what our goal is, what constraints we have, how we&rsquo;d like to approach the corner and exceptional cases (fail fast or continue gracefully) we&rsquo;ll have different results.<br>
Pay attention to details, apply as much care to the system and its smaller parts.</p>
<p>Happy coding.</p>

  </div>
  

<div class="navigation navigation-single">
    
    <a href="/posts/2020_10_17_kotlin_functional_interfaces_function_references_and_sam_conversion/" class="navigation-prev">
      <i aria-hidden="true" class="fa fa-chevron-left"></i>
      <span class="navigation-tittle">Kotlin Functional Interfaces: Function reference and SAM conversion</span>
    </a>
    
    
    <a href="/posts/2020_10_31_boolean_not/" class="navigation-next">
      <span class="navigation-tittle">Boolean not</span>
      <i aria-hidden="true" class="fa fa-chevron-right"></i>
    </a>
    
</div>


  

  
    


</article>


        </div>
        
    

  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-148934073-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<script defer src="https://use.fontawesome.com/releases/v5.12.1/js/all.js" integrity="sha384-ZbbbT1gw3joYkKRqh0kWyRp32UAvdqkpbLedQJSlnI8iLQcFVxaGyrOgOJiDQTTR" crossorigin="anonymous"></script>


    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
        
            
                <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/bash.min.js"></script>
            
                <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/java.min.js"></script>
            
                <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/kotlin.min.js"></script>
            
        
    <script type="text/javascript">
        
        hljs.configure({languages: ["bash, java, kotlin"]});
        
        hljs.initHighlightingOnLoad();
    </script>
    



    



    </body>
</html>
