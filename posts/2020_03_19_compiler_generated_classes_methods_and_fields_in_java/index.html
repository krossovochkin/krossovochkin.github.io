<!DOCTYPE html>
<html lang="en-us">
<head>
  <title>Compiler-generated classes, methods and fields in Java</title>

  <link rel="icon" type="image/png" href="favicon.png">
  <link rel="apple-touch-icon" href="apple-touch-icon-144-precompressed.png"/>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/styles/androidstudio.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <script src="https://kit.fontawesome.com/6d5aec2882.js" crossorigin="anonymous"></script>

  <link rel="stylesheet" href="/css/style.css" />

  <link rel="me" href="https://androiddev.social/@krossovochkin" />

  
  <meta name="theme-color" content="#1e2327">

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Compiler-generated classes, methods and fields in Java">
  <meta name="twitter:description" content="Looking at what compiler can generate and in which situations.">

</head>

<body>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-YEWQ4T95D5"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-YEWQ4T95D5');
        }
      </script>

<header>
<nav>
  <ul>
    
    <li class="menu-left"><a href="/about">About</a></li>
    
    <li class="menu-left"><a href="/">Posts</a></li>
    
    <li class="menu-left"><a href="/apps">Apps</a></li>
    
    
    <li class="menu-right"><a rel="me" href="https://t.me/krossovochkin_newsletter" target="_blank"><i class="fa-brands fa-telegram fa-l"></i></a></li>
    
    <li class="menu-right"><a rel="me" href="https://stackoverflow.com/users/1533933/krossovochkin" target="_blank"><i class="fa-brands fa-stack-overflow fa-l"></i></a></li>
    
    <li class="menu-right"><a rel="me" href="https://linkedin.com/in/vasyadrobushkov" target="_blank"><i class="fa-brands fa-linkedin fa-l"></i></a></li>
    
    <li class="menu-right"><a rel="me" href="https://facebook.com/vasya.drobushkov" target="_blank"><i class="fa-brands fa-facebook fa-l"></i></a></li>
    
    <li class="menu-right"><a rel="me" href="/index.xml" target="_blank"><i class="fa-solid fa-rss fa-l"></i></a></li>
    
    <li class="menu-right"><a rel="me" href="https://androiddev.social/@krossovochkin" target="_blank"><i class="fa-brands fa-mastodon fa-l"></i></a></li>
    
    <li class="menu-right"><a rel="me" href="https://github.com/krossovochkin" target="_blank"><i class="fa-brands fa-github fa-l"></i></a></li>
    
  </ul>
</nav>

</header>

<br/>


<div class="meta">

  
    <h1><span class="title">Compiler-generated classes, methods and fields in Java</span></h1>
  
  
    <h3>March 19, 2020</h3>
  

</div>

<main>
<p><img src="https://images.unsplash.com/photo-1563951163384-ddbc3fbaacd4?ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1357&amp;q=80" alt="Source"><em><a href="https://unsplash.com/photos/tdsG7cUNrOo">Source</a></em></p>
<p><a href="https://medium.com/javarevisited/compiler-generated-classes-methods-and-fields-in-java-343dde2cce61"><img src="https://img.shields.io/badge/original-medium-green#badge" alt=""></a></p>
<h2 id="introduction">Introduction</h2>
<p>When we write program in Java we create some classes, methods, fields and put all of this into our source code — .java files. After these files are compiled with javac (Java Compiler) into .class files we got a bunch of Java bytecode.
It turns out that not only we create classes, methods and fields in our source code, but also compiler by itself can create them when needed.
In this article we’ll try to get into the compiler-generated topic, will find out what are synthetic and bridge, access flags, learn some new things from official documentation and maybe more.
Let’s dive in.</p>
<h2 id="synthetic-definition">Synthetic definition</h2>
<p>Class, method and field can be synthetic, which means that it doesn’t appear in source code (therefore it is generated by compiler).
<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.8">Reference</a></p>
<p>Basically that simple. If something was generated by compiler (which wasn’t in source code) then compiler has to mark such generated thing as being synthetic.</p>
<blockquote>
<p><strong>NOTE</strong>: there are exceptions to such a rule, like default constructor — it won’t be marked as synthetic. The complete list of exceptions one can find in the <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.8">specification</a>.</p>
</blockquote>
<h3 id="nested-class">Nested class</h3>
<p>Classic example on when synthetic is used by a compiler is nested class (one which holds reference to parent).
First we’ll take a look at inner (static) class and bytecode generated.
Our example will be:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Main</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">static</span><span class="w"> </span><span class="n">Child</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Next we’ll compile it with: javac Main.java
It will produce two files: Main.class and Main$Child.class.
To look at the generated code we’ll use javap:javap -v Main$Child.class</p>
<p>Part of generated result will be:</p>
<pre tabindex="0"><code>{
  Main$Child();
    descriptor: ()V
    flags:
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1   // Method java/lang/Object.&#34;&lt;init&gt;&#34;:()V
         4: return
</code></pre><p>What we see here is our class declared with default constructor (<init>). No any reference to Main class is kept by Child class (because it is static).</p>
<p>If we remove static modifier and repeat the procedure, that’s what we’ll see:</p>
<pre tabindex="0"><code>class Main$Child
...
{
  final Main this$0;
    descriptor: LMain;
    flags: ACC_FINAL, ACC_SYNTHETIC

  Main$Child(Main);
    descriptor: (LMain;)V
    flags:
    Code:
      stack=2, locals=2, args_size=2
         0: aload_0
         1: aload_1
         2: putfield      #1     // Field this$0:LMain;
         5: aload_0
         6: invokespecial #2     // Method java/lang/Object.&#34;&lt;init&gt;&#34;:()V
         9: return
</code></pre><p>As we see we now have this$0 reference to our parent class, which is passed inside constructor.
Also pay attention that that field has ACC_SYNTHETIC flag, which shows that field is synthetic — was generated by compiler.</p>
<p>This reference to parent is not something that is added just in case, it is useful in the cases where nested class wants to access instance methods and fields of parent class (including private ones).</p>
<p>For example:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Main</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">class</span> <span class="nc">Child</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">foo</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Here we’ll use javap with -p flag to see private members:</p>
<pre tabindex="0"><code>class Main$Child
...
{
  final Main this$0;
    descriptor: LMain;
    flags: ACC_FINAL, ACC_SYNTHETIC

  Main$Child(Main);
    descriptor: (LMain;)V
    flags:
    Code:
      stack=2, locals=2, args_size=2
         0: aload_0
         1: aload_1
         2: putfield      #1     // Field this$0:LMain;
         5: aload_0
         6: invokespecial #2     // Method java/lang/Object.&#34;&lt;init&gt;&#34;:()V
         9: return
      LineNumberTable:
        line 4: 0

  private void bar();
    descriptor: ()V
    flags: ACC_PRIVATE
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: getfield      #1          // Field this$0:LMain;
         4: invokestatic  #3          // Method Main.access$000:(LMain;)V
         7: return
</code></pre><p>Here we see not only synthetic field but also our private method bar is calling method acess$000 on reference to parent. But what it is? Let’s take a look at the bytecode of Main class:</p>
<pre tabindex="0"><code>class Main
...
{
  Main();
    descriptor: ()V
    flags:
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #2      // Method java/lang/Object.&#34;&lt;init&gt;&#34;:()V
         4: return
      LineNumberTable:
        line 1: 0

  private void foo();
    descriptor: ()V
    flags: ACC_PRIVATE
    Code:
      stack=0, locals=1, args_size=1
         0: return
      LineNumberTable:
        line 2: 0

  static void access$000(Main);
    descriptor: (LMain;)V
    flags: ACC_STATIC, ACC_SYNTHETIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method foo:()V
         4: return
</code></pre><p>Here we see that not only we have private foo method, but also static method access$000 which also has ACC_SYNTHETIC flag — so it is synthetic as well. And it was generated by compiler for Child class to be able to access private method foo.</p>
<h3 id="heading">$</h3>
<p>Specially need to note usage of $ sign in the generated code. It is used heavily especially for generated by compiler things. Because of that is not recommended to use $ sign in class, method, field etc. names in java source code.</p>
<h3 id="anonymous-class">Anonymous class</h3>
<p>Next example we’ll take a look at anonymous classes. We’ll try to create some runnable and see what will be in bytecode.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Main</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">new</span><span class="w"> </span><span class="n">Runnable</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">run</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>We’ll see that there will be two .class files: Main.class and Main$1.class. Second one is created for our anonymous Runnable and inside we’ll see the following:</p>
<pre tabindex="0"><code>class Main$1 implements java.lang.Runnable
...
{
  final Main this$0;
    descriptor: LMain;
    flags: ACC_FINAL, ACC_SYNTHETIC

  Main$1(Main);
    descriptor: (LMain;)V
    flags:
    Code:
      stack=2, locals=2, args_size=2
         0: aload_0
         1: aload_1
         2: putfield      #1     // Field this$0:LMain;
         5: aload_0
         6: invokespecial #2     // Method java/lang/Object.&#34;&lt;init&gt;&#34;:()V
         9: return
      LineNumberTable:
        line 4: 0

  public void run();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=0, locals=1, args_size=1
         0: return
</code></pre><p>Here we see same picture: anonymous class keeps reference to parent class in a synthetic field.</p>
<h3 id="type-erasure-and-bridge-methods">Type erasure and bridge methods</h3>
<p>In Java when using generics there is one important limitation: generics are not available at runtime. The process of removing all the information about generics at compile time is called type erasure.
That means that if you use in code List<String> in resulting bytecode it will become just List without any generic.
Applying that let’s imagine what could happen in the following case. We’ll create some class and make it comparable with classes of same type.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">MyInt</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Comparable</span><span class="o">&lt;</span><span class="n">MyInt</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">compareTo</span><span class="p">(</span><span class="n">MyInt</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// TODO: implement</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>If we apply type erasure it would mean that effectively our class will have method compareTo(MyInt other) at the same time implementing Comparable without any type information (which means that we are working with Object).
In this case as we don’t have compareTo(Object other) method nothing seems will work.
Here to help comes special type of synthetic — bridge methods.</p>
<p>If we decompile our MyInt.class:</p>
<pre tabindex="0"><code>class MyInt extends java.lang.Object implements java.lang.Comparable&lt;MyInt&gt;
...
{
  MyInt();
    descriptor: ()V
    flags:
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1   // Method java/lang/Object.&#34;&lt;init&gt;&#34;:()V
         4: return
      LineNumberTable:
        line 1: 0

public int compareTo(MyInt);
    descriptor: (LMyInt;)I
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=2, args_size=2
         0: iconst_0
         1: ireturn
      LineNumberTable:
        line 4: 0

public int compareTo(java.lang.Object);
    descriptor: (Ljava/lang/Object;)I
    flags: ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC
    Code:
      stack=2, locals=2, args_size=2
         0: aload_0
         1: aload_1
         2: checkcast     #2      // class MyInt
         5: invokevirtual #3      // Method compareTo:(LMyInt;)I
         8: ireturn
</code></pre><p>We see here that besides our compareTo(MyInt) method we have also compareTo(javalang.Object) method which is marked with ACC_SYNTHETIC flag, which means that it is synthetic. But also it has ACC_BRIDGE flag.
What bridge methods do is handle type erased methods and after checking provided value types (by checkcast) redirect call to the original typed version of method.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Synthetic and bridge are pretty powerful concepts, which allow us to have some features which would be problematic to have if we don’t have them.
Other languages such as Kotlin also rely on synthetic in some features especially when adding Java compatibility. For example default params in methods.
Hope this article was useful for you.</p>
<p>Happy coding!</p>

</main>


<hr/>

<footer>
<nav>
  <ul>
    
    <li class="menu-left"><a href="/about">About</a></li>
    
    <li class="menu-left"><a href="/">Posts</a></li>
    
    <li class="menu-left"><a href="/apps">Apps</a></li>
    
    
    <li class="menu-right"><a rel="me" href="https://t.me/krossovochkin_newsletter" target="_blank"><i class="fa-brands fa-telegram fa-l"></i></a></li>
    
    <li class="menu-right"><a rel="me" href="https://stackoverflow.com/users/1533933/krossovochkin" target="_blank"><i class="fa-brands fa-stack-overflow fa-l"></i></a></li>
    
    <li class="menu-right"><a rel="me" href="https://linkedin.com/in/vasyadrobushkov" target="_blank"><i class="fa-brands fa-linkedin fa-l"></i></a></li>
    
    <li class="menu-right"><a rel="me" href="https://facebook.com/vasya.drobushkov" target="_blank"><i class="fa-brands fa-facebook fa-l"></i></a></li>
    
    <li class="menu-right"><a rel="me" href="/index.xml" target="_blank"><i class="fa-solid fa-rss fa-l"></i></a></li>
    
    <li class="menu-right"><a rel="me" href="https://androiddev.social/@krossovochkin" target="_blank"><i class="fa-brands fa-mastodon fa-l"></i></a></li>
    
    <li class="menu-right"><a rel="me" href="https://github.com/krossovochkin" target="_blank"><i class="fa-brands fa-github fa-l"></i></a></li>
    
  </ul>
</nav>

</footer>


</body>

</html>